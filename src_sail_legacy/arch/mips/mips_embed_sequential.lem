(*Generated by Sail from mips.sail.*)
open import Pervasives_extra
open import Sail_impl_base
open import State
open import Sail_values
open import Mips_embed_types
open import Mips_extras_embed_sequential
let TLBNumEntries = (64:ii)

let MAX_U64 =
  unsigned
    (reset_vector_start (set_vector_start_to_length
      (Vector [B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
               B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
               B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
               B1] 63 false)))

let MAX_VA =
  unsigned
    (reset_vector_start (set_vector_start_to_length
      (Vector [B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
               B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1] 39 false)))

let MAX_PA =
  unsigned
    (reset_vector_start (set_vector_start_to_length
      (Vector [B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
               B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1] 35 false)))

let NotWordVal word =
  neq_vec
    (set_vector_start_to_length (duplicate (access word (31:ii), (32:ii))),
    set_vector_start_to_length (slice word (63:ii) (32:ii)))

let alignment_width = (16:ii)

let rec reverse_endianness value =
  let width = length (reset_vector_start (set_vector_start_to_length value)) in
  if bitU_to_bool (lteq (width, (8:ii)))
  then set_vector_start_to_length value
  else
    set_vector_start_to_length
      ((set_vector_start_to_length (slice (set_vector_start_to_length value) (7:ii) (0:ii))) ^^
       (set_vector_start_to_length
         (reverse_endianness
            (reset_vector_start (set_vector_start_to_length
              (slice (set_vector_start_to_length value) (width - (1:ii)) (8:ii)))))))

let have_cp2 = B0

let ERETHook () = ()

let GPRs =
  Vector ["GPR00";"GPR01";"GPR02";"GPR03";"GPR04";"GPR05";"GPR06";"GPR07";"GPR08";"GPR09";"GPR10";"GPR11";"GPR12";"GPR13";"GPR14";"GPR15";"GPR16";"GPR17";"GPR18";"GPR19";"GPR20";
          "GPR21";"GPR22";"GPR23";"GPR24";"GPR25";"GPR26";"GPR27";"GPR28";"GPR29";"GPR30";"GPR31"] 0 true

let TLBIndexMax = Vector [B1;B1;B1;B1;B1;B1] 5 false

let MEMr_reserve_wrapper (addr, size) =
  MEMr_reserve (reset_vector_start addr,size) >>= fun w__0 ->
  return (set_vector_start_to_length
    (reverse_endianness (reset_vector_start (set_vector_start_to_length w__0))))

let tlbSearch VAddr = Nothing

let TLBTranslate (vAddr, accessType) = vAddr

let TLBTranslateC (vAddr, accessType) = (vAddr,B0)

let MEMw_conditional_wrapper (addr, size, data) =
  MEMea_conditional (reset_vector_start addr,size) >>
  MEMval_conditional
    (reset_vector_start addr,
     size,
     reset_vector_start (set_vector_start_to_length (reverse_endianness (reset_vector_start data))))

let addrWrapper (addr, accessType, width) = addr

let CIA_fp = RFull "CIA"

let NIA_fp = RFull "NIA"

let MEMr_wrapper (addr, size) =
  if bitU_to_bool
       (eq_vec
          (set_vector_start_to_length addr,
          set_vector_start_to_length
            (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1;B1;B1;B1;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0] 63 false)))
  then
    read_reg UART_RVALID >>= fun rvalid ->
    read_reg UART_RDATA >>= fun w__0 ->
    let rdata =
      mask
        ((8:ii) * size,
         reset_vector_start (set_vector_start_to_length
           ((set_vector_start_to_length
              (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 31 false)) ^^
            (set_vector_start_to_length
              (w__0 ^^
               (set_vector_start_to_length
                 ((set_vector_start_to_length
                    (Vector [most_significant (reset_vector_start rvalid)] 0 false)) ^^
                  (set_vector_start_to_length
                    ((set_vector_start_to_length (Vector [B0;B0;B0;B0;B0;B0;B0] 6 false)) ^^
                     (set_vector_start_to_length
                       (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 15 false))))))))))) in
    write_reg UART_RVALID (Vector [B0] 0 false) >>
    return (set_vector_start_to_length rdata)
  else
    if bitU_to_bool
         (eq_vec
            (set_vector_start_to_length addr,
            set_vector_start_to_length
              (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1;B1;B1;B1;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;
                       B0] 63 false)))
    then
      return (set_vector_start_to_length
        (mask
           ((8:ii) * size,
            reset_vector_start (set_vector_start_to_length
              (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B1;B0;B0;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                       B1] 63 false)))))
    else
      MEMr (reset_vector_start addr,size) >>= fun w__1 ->
      return (set_vector_start_to_length
        (reverse_endianness (reset_vector_start (set_vector_start_to_length w__1))))

let MEMw_wrapper (addr, size, data) =
  let ledata = reverse_endianness (reset_vector_start data) in
  if bitU_to_bool
       (eq
          (addr,
          Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1;B1;B1;B1;B0;B0;
                  B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0] 63 false))
  then
    write_reg UART_WDATA (slice (set_vector_start_to_length ledata) (7:ii) (0:ii)) >>
    write_reg UART_WRITTEN (to_vec_dec ((1:ii),(1:ii)))
  else
    MEMea (reset_vector_start addr,size) >>
    MEMval (reset_vector_start addr,size,reset_vector_start (set_vector_start_to_length ledata))

let int_of_accessLevel x =
  match x with | User -> (0:ii) | Supervisor -> (1:ii) | Kernel -> (2:ii) end

let wordWidthBytes w = match w with | B -> (1:ii) | H -> (2:ii) | W -> (4:ii) | D -> (8:ii) end

let getAccessLevel () =
  read_reg_bitfield CP0Status "EXL" >>= fun w__0 ->
  read_reg_bitfield CP0Status "ERL" >>= fun w__1 ->
  if bitU_to_bool (w__0 |. w__1)
  then return Kernel
  else
    read_reg_field CP0Status "KSU" >>= fun w__2 ->
    return (match w__2 with
            | Vector [B0;B0] _ _ -> Kernel
            | Vector [B0;B1] _ _ -> Supervisor
            | Vector [B1;B0] _ _ -> User
            | _ -> User
            end)

let compare (cmp, valA, valB) =
  let valA65 =
    (set_vector_start_to_length (Vector [B0] 0 false)) ^^ (set_vector_start_to_length valA) in
  let valB65 =
    (set_vector_start_to_length (Vector [B0] 0 false)) ^^ (set_vector_start_to_length valB) in
  match cmp with
  | EQ' -> eq_vec (set_vector_start_to_length valA, set_vector_start_to_length valB)
  | NE -> neq_vec (set_vector_start_to_length valA, set_vector_start_to_length valB)
  | GE -> gteq_vec (set_vector_start_to_length valA, set_vector_start_to_length valB)
  | GEU -> gteq_vec (set_vector_start_to_length valA65, set_vector_start_to_length valB65)
  | GT' -> gt_vec (set_vector_start_to_length valA, set_vector_start_to_length valB)
  | LE -> lteq_vec (set_vector_start_to_length valA, set_vector_start_to_length valB)
  | LT' -> lt_vec (set_vector_start_to_length valA, set_vector_start_to_length valB)
  | LTU -> lt_vec (set_vector_start_to_length valA65, set_vector_start_to_length valB65)
  end

let ExceptionCode ex =
  match ex with
  | Int ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B0;B0;B0;B0] 7 false))))
  | TLBMod ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B0;B0;B0;B1] 7 false))))
  | TLBL ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B0;B0;B1;B0] 7 false))))
  | TLBS ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B0;B0;B1;B1] 7 false))))
  | AdEL ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B0;B1;B0;B0] 7 false))))
  | AdES ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B0;B1;B0;B1] 7 false))))
  | Sys ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B1;B0;B0;B0] 7 false))))
  | Bp ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B1;B0;B0;B1] 7 false))))
  | ResI ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B1;B0;B1;B0] 7 false))))
  | CpU ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B1;B0;B1;B1] 7 false))))
  | Ov ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B1;B1;B0;B0] 7 false))))
  | Tr ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B1;B1;B0;B1] 7 false))))
  | C2E ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B1;B0;B0;B1;B0] 7 false))))
  | C2Trap ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B1;B0;B0;B1;B0] 7 false))))
  | XTLBRefillL ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B0;B0;B1;B0] 7 false))))
  | XTLBRefillS ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B0;B0;B1;B1] 7 false))))
  | XTLBInvL ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B0;B0;B1;B0] 7 false))))
  | XTLBInvS ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B0;B0;B0;B1;B1] 7 false))))
  | MCheck ->
     set_vector_start 4
       (mask
          ((5:ii),
           reset_vector_start (set_vector_start_to_length (Vector [B0;B0;B0;B1;B1;B0;B0;B0] 7 false))))
  end

let GPR =
  Vector [GPR00;GPR01;GPR02;GPR03;GPR04;GPR05;GPR06;GPR07;GPR08;GPR09;GPR10;GPR11;GPR12;GPR13;GPR14;GPR15;GPR16;GPR17;GPR18;GPR19;GPR20;
          GPR21;GPR22;GPR23;GPR24;GPR25;GPR26;GPR27;GPR28;GPR29;GPR30;GPR31] 0 true

let TLBEntries =
  Vector [TLBEntry00;TLBEntry01;TLBEntry02;TLBEntry03;TLBEntry04;TLBEntry05;TLBEntry06;TLBEntry07;TLBEntry08;TLBEntry09;TLBEntry10;TLBEntry11;TLBEntry12;TLBEntry13;TLBEntry14;TLBEntry15;TLBEntry16;TLBEntry17;TLBEntry18;TLBEntry19;TLBEntry20;
          TLBEntry21;TLBEntry22;TLBEntry23;TLBEntry24;TLBEntry25;TLBEntry26;TLBEntry27;TLBEntry28;TLBEntry29;TLBEntry30;TLBEntry31;TLBEntry32;TLBEntry33;TLBEntry34;TLBEntry35;TLBEntry36;TLBEntry37;TLBEntry38;TLBEntry39;TLBEntry40;TLBEntry41;
          TLBEntry42;TLBEntry43;TLBEntry44;TLBEntry45;TLBEntry46;TLBEntry47;TLBEntry48;TLBEntry49;TLBEntry50;TLBEntry51;TLBEntry52;TLBEntry53;TLBEntry54;TLBEntry55;TLBEntry56;TLBEntry57;TLBEntry58;TLBEntry59;TLBEntry60;TLBEntry61;TLBEntry62;
          TLBEntry63] 0 true

let rGPR idx =
  if bitU_to_bool (eq_vec_range (set_vector_start_to_length idx, (0:ii)))
  then return (to_vec_dec ((64:ii),(0:ii)))
  else read_reg (access GPR (unsigned (reset_vector_start idx)))

let wGPR (idx, v) =
  if bitU_to_bool (eq_vec_range (set_vector_start_to_length idx, (0:ii)))
  then return ()
  else write_reg (access GPR (unsigned (reset_vector_start idx))) v

let isAddressAligned (addr, wordType) =
  let a = unsigned (reset_vector_start addr) in
  eq_range (quot a alignment_width, quot ((a + (wordWidthBytes wordType)) - (1:ii)) alignment_width)

let SignalExceptionMIPS (ex, kccBase) =
  read_reg_bitfield CP0Status "EXL" >>= fun w__0 ->
  (if bitU_to_bool (~w__0)
   then
     read_reg_bit inBranchDelay (0:ii) >>= fun w__1 ->
     if bitU_to_bool w__1
     then
       read_reg PC >>= fun w__2 ->
       write_reg CP0EPC (set_vector_start 63 (minus_VIV w__2 (4:ii))) >>
       write_reg_bitfield CP0Cause "BD" B1
     else
       read_reg PC >>= fun w__3 ->
       write_reg CP0EPC w__3 >>
       write_reg_bitfield CP0Cause "BD" B0
   else return ()) >>
  read_reg_bitfield CP0Status "EXL" >>= fun w__4 ->
  let vectorOffset =
    if bitU_to_bool w__4
    then Vector [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0] 11 false
    else
      if bitU_to_bool ((eq (ex, XTLBRefillL)) |. (eq (ex, XTLBRefillS)))
      then Vector [B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0] 11 false
      else
        if bitU_to_bool (eq (ex, C2Trap))
        then Vector [B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0;B0] 11 false
        else Vector [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0] 11 false in
  read_reg_bitfield CP0Status "BEV" >>= fun w__5 ->
  let vectorBase =
    if bitU_to_bool w__5
    then
      Vector [B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
              B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B0;B1;B1;B1;B1;B1;B1;B1;B1;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;
              B0] 63 false
    else
      Vector [B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
              B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0] 63 false in
  write_reg
    nextPC
    (minus_VVV
       (reset_vector_start (set_vector_start 63
         (add_VVV
            (reset_vector_start (set_vector_start_to_length vectorBase))
            (reset_vector_start (set_vector_start_to_length
              (exts ((64:ii),reset_vector_start (set_vector_start_to_length vectorOffset))))))))
       (reset_vector_start (set_vector_start_to_length kccBase))) >>
  write_reg_field CP0Cause "ExcCode" (set_vector_start 6 (ExceptionCode ex)) >>
  write_reg_bitfield CP0Status "EXL" B1 >>
  exit ()

let supported_instructions instr = Just instr

let SignalException ex =
  SignalExceptionMIPS
    (ex,
     reset_vector_start (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                 B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                 B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                 B0] 63 false))

let SignalExceptionBadAddr (ex, badAddr) =
  write_reg CP0BadVAddr badAddr >>
  SignalException ex

let SignalExceptionTLB (ex, badAddr) =
  write_reg CP0BadVAddr badAddr >>
  write_reg_field TLBContext "BadVPN2" (set_vector_start 22 (slice badAddr (31:ii) (13:ii))) >>
  write_reg_field TLBXContext "BadVPN2" (set_vector_start 30 (slice badAddr (39:ii) (13:ii))) >>
  write_reg_field TLBXContext "R" (set_vector_start 32 (slice badAddr (63:ii) (62:ii))) >>
  write_reg_field TLBEntryHi "R" (slice badAddr (63:ii) (62:ii)) >>
  write_reg_field TLBEntryHi "VPN2" (slice badAddr (39:ii) (13:ii)) >>
  SignalException ex

let incrementCP0Count () =
  read_reg TLBRandom >>= fun w__0 ->
  read_reg TLBWired >>= fun w__1 ->
  (if bitU_to_bool (eq_vec (w__0, w__1))
   then return TLBIndexMax
   else
     read_reg TLBRandom >>= fun w__2 ->
     return (minus_VIV w__2 (1:ii))) >>= fun w__3 ->
  write_reg TLBRandom w__3 >>
  read_reg CP0Count >>= fun w__4 ->
  write_reg CP0Count (set_vector_start 31 (add_VIV w__4 (1:ii))) >>
  read_reg CP0Count >>= fun w__5 ->
  read_reg CP0Compare >>= fun w__6 ->
  (if bitU_to_bool (eq_vec (w__5, w__6))
   then write_reg_bit CP0Cause (15:ii) B1
   else return ()) >>
  read_reg_field CP0Status "IM" >>= fun w__7 ->
  let ims = set_vector_start 7 w__7 in
  read_reg_field CP0Cause "IP" >>= fun w__8 ->
  let ips = set_vector_start 7 w__8 in
  read_reg_bitfield CP0Status "IE" >>= fun ie ->
  read_reg_bitfield CP0Status "EXL" >>= fun exl ->
  read_reg_bitfield CP0Status "ERL" >>= fun erl ->
  if bitU_to_bool
       ((~exl) &.
          ((~erl) &.
             (ie &.
                (neq_vec
                   (set_vector_start_to_length
                     (bitwise_and (set_vector_start_to_length ips, set_vector_start_to_length ims)),
                   set_vector_start_to_length (Vector [B0;B0;B0;B0;B0;B0;B0;B0] 7 false))))))
  then SignalException Int
  else return ()

let checkCP0Access () =
  getAccessLevel () >>= fun accessLevel ->
  read_reg_bit CP0Status (28:ii) >>= fun w__0 ->
  if bitU_to_bool ((neq (accessLevel, Kernel)) &. (~w__0))
  then
    write_reg_field CP0Cause "CE" (set_vector_start 29 (Vector [B0;B0] 1 false)) >>
    SignalException CpU
  else return ()

let TLBWriteEntry idx =
  read_reg TLBPageMask >>= fun w__0 ->
  let pagemask = extz ((16:ii),w__0) in
  match pagemask with
  | Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] _ _ -> return ()
  | Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1] _ _ -> return ()
  | Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1] _ _ -> return ()
  | Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1;B1;B1] _ _ -> return ()
  | Vector [B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1;B1;B1;B1;B1] _ _ -> return ()
  | Vector [B0;B0;B0;B0;B0;B0;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1] _ _ -> return ()
  | Vector [B0;B0;B0;B0;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1] _ _ -> return ()
  | Vector [B0;B0;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1] _ _ -> return ()
  | Vector [B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1] _ _ -> return ()
  | _ -> SignalException MCheck
  end >>
  write_reg_field (access TLBEntries (unsigned idx)) "pagemask" (set_vector_start 116 pagemask) >>
  read_reg_field TLBEntryHi "R" >>= fun w__1 ->
  write_reg_field (access TLBEntries (unsigned idx)) "r" (set_vector_start 100 w__1) >>
  read_reg_field TLBEntryHi "VPN2" >>= fun w__2 ->
  write_reg_field (access TLBEntries (unsigned idx)) "vpn2" (set_vector_start 98 w__2) >>
  read_reg_field TLBEntryHi "ASID" >>= fun w__3 ->
  write_reg_field (access TLBEntries (unsigned idx)) "asid" (set_vector_start 71 w__3) >>
  read_reg_bitfield TLBEntryLo0 "G" >>= fun w__4 ->
  read_reg_bitfield TLBEntryLo1 "G" >>= fun w__5 ->
  write_reg_bitfield (access TLBEntries (unsigned idx)) "g" (w__4 &. w__5) >>
  write_reg_bitfield (access TLBEntries (unsigned idx)) "valid" B1 >>
  read_reg_bitfield TLBEntryLo0 "CapS" >>= fun w__6 ->
  write_reg_bitfield (access TLBEntries (unsigned idx)) "caps0" w__6 >>
  read_reg_bitfield TLBEntryLo0 "CapL" >>= fun w__7 ->
  write_reg_bitfield (access TLBEntries (unsigned idx)) "capl0" w__7 >>
  read_reg_field TLBEntryLo0 "PFN" >>= fun w__8 ->
  write_reg_field (access TLBEntries (unsigned idx)) "pfn0" (set_vector_start 28 w__8) >>
  read_reg_field TLBEntryLo0 "C" >>= fun w__9 ->
  write_reg_field (access TLBEntries (unsigned idx)) "c0" (set_vector_start 4 w__9) >>
  read_reg_bitfield TLBEntryLo0 "D" >>= fun w__10 ->
  write_reg_bitfield (access TLBEntries (unsigned idx)) "d0" w__10 >>
  read_reg_bitfield TLBEntryLo0 "V" >>= fun w__11 ->
  write_reg_bitfield (access TLBEntries (unsigned idx)) "v0" w__11 >>
  read_reg_bitfield TLBEntryLo1 "CapS" >>= fun w__12 ->
  write_reg_bitfield (access TLBEntries (unsigned idx)) "caps1" w__12 >>
  read_reg_bitfield TLBEntryLo1 "CapL" >>= fun w__13 ->
  write_reg_bitfield (access TLBEntries (unsigned idx)) "capl1" w__13 >>
  read_reg_field TLBEntryLo1 "PFN" >>= fun w__14 ->
  write_reg_field (access TLBEntries (unsigned idx)) "pfn1" (set_vector_start 59 w__14) >>
  read_reg_field TLBEntryLo1 "C" >>= fun w__15 ->
  write_reg_field (access TLBEntries (unsigned idx)) "c1" (set_vector_start 35 w__15) >>
  read_reg_bitfield TLBEntryLo1 "D" >>= fun w__16 ->
  write_reg_bitfield (access TLBEntries (unsigned idx)) "d1" w__16 >>
  read_reg_bitfield TLBEntryLo1 "V" >>= fun w__17 ->
  write_reg_bitfield (access TLBEntries (unsigned idx)) "v1" w__17

let TranslatePC vAddr =
  incrementCP0Count () >>
  if bitU_to_bool
       (neq_vec
          (set_vector_start_to_length (slice vAddr (1:ii) (0:ii)),
          set_vector_start_to_length (Vector [B0;B0] 1 false)))
  then SignalExceptionBadAddr (AdEL,reset_vector_start vAddr)
  else return (TLBTranslate (reset_vector_start vAddr,Instruction))

let initial_analysis instr =
  let iR = [] in
  let oR = [] in
  let aR = [] in
  let ik = IK_simple in
  let Nias = [] in
  let Dia = DIAFP_none in
  match instr with
  | DADDIU (rs,rt,imm) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | DADDU (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | DADDI (rs,rt,imm) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | DADD (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | ADD (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | ADDI (rs,rt,imm) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | ADDU (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | ADDIU (rs,rt,imm) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | DSUBU (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | DSUB (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | SUB (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | SUBU (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | AND (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | ANDI (rs,rt,imm) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | OR (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | ORI (rs,rt,imm) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | NOR (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | XOR (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | XORI (rs,rt,imm) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | LUI (rt,imm) ->
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | DSLL (rt,rd,sa) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | DSLL32 (rt,rd,sa) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | DSLLV (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | DSRA (rt,rd,sa) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | DSRA32 (rt,rd,sa) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | DSRAV (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | DSRL (rt,rd,sa) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | DSRL32 (rt,rd,sa) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | DSRLV (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | SLL (rt,rd,sa) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | SLLV (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | SRA (rt,rd,sa) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | SRAV (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | SRL (rt,rd,sa) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | SRLV (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | SLT (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | SLTI (rs,rt,imm) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | SLTU (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | SLTIU (rs,rt,imm) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | MOVN (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | MOVZ (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | MFHI (rd) ->
     let iR = (RFull "HI") :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | MFLO (rd) ->
     let iR = (RFull "LO") :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | MTHI (rs) ->
     let oR = (RFull "HI") :: oR in
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     return (aR,ik,Dia,iR,oR)
  | MTLO (rs) ->
     let oR = (RFull "LO") :: oR in
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     return (aR,ik,Dia,iR,oR)
  | MUL (rs,rt,rd) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rd))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | MULT (rs,rt) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR = (RFull "HI") :: (RFull "LO") :: oR in
     return (aR,ik,Dia,iR,oR)
  | MULTU (rs,rt) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR = (RFull "HI") :: (RFull "LO") :: oR in
     return (aR,ik,Dia,iR,oR)
  | DMULT (rs,rt) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR = (RFull "HI") :: (RFull "LO") :: oR in
     return (aR,ik,Dia,iR,oR)
  | DMULTU (rs,rt) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR = (RFull "HI") :: (RFull "LO") :: oR in
     return (aR,ik,Dia,iR,oR)
  | MADD (rs,rt) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let iR = (RFull "HI") :: (RFull "LO") :: iR in
     let oR = (RFull "HI") :: (RFull "LO") :: oR in
     return (aR,ik,Dia,iR,oR)
  | MADDU (rs,rt) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let iR = (RFull "HI") :: (RFull "LO") :: iR in
     let oR = (RFull "HI") :: (RFull "LO") :: oR in
     return (aR,ik,Dia,iR,oR)
  | MSUB (rs,rt) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let iR = (RFull "HI") :: (RFull "LO") :: iR in
     let oR = (RFull "HI") :: (RFull "LO") :: oR in
     return (aR,ik,Dia,iR,oR)
  | MSUBU (rs,rt) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let iR = (RFull "HI") :: (RFull "LO") :: iR in
     let oR = (RFull "HI") :: (RFull "LO") :: oR in
     return (aR,ik,Dia,iR,oR)
  | DIV (rs,rt) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR = (RFull "HI") :: (RFull "LO") :: oR in
     return (aR,ik,Dia,iR,oR)
  | DIVU (rs,rt) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR = (RFull "HI") :: (RFull "LO") :: oR in
     return (aR,ik,Dia,iR,oR)
  | DDIV (rs,rt) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR = (RFull "HI") :: (RFull "LO") :: oR in
     return (aR,ik,Dia,iR,oR)
  | DDIVU (rs,rt) ->
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     let oR = (RFull "HI") :: (RFull "LO") :: oR in
     return (aR,ik,Dia,iR,oR)
  | J (offset) ->
     let ik = IK_branch in
     read_reg PC >>= fun w__0 ->
     let Dia =
       DIAFP_concrete (reset_vector_start (set_vector_start 63
         ((set_vector_start_to_length
            (slice (set_vector_start_to_length (add_VIV w__0 (4:ii))) (63:ii) (28:ii))) ^^
          (set_vector_start_to_length
            ((set_vector_start_to_length offset) ^^
             (set_vector_start_to_length (Vector [B0;B0] 1 false))))))) in
     return (aR,ik,Dia,iR,oR)
  | JAL (offset) ->
     let ik = IK_branch in
     let oR = (RFull "GPR31") :: oR in
     read_reg PC >>= fun w__1 ->
     let Dia =
       DIAFP_concrete (reset_vector_start (set_vector_start 63
         ((set_vector_start_to_length
            (slice (set_vector_start_to_length (add_VIV w__1 (4:ii))) (63:ii) (28:ii))) ^^
          (set_vector_start_to_length
            ((set_vector_start_to_length offset) ^^
             (set_vector_start_to_length (Vector [B0;B0] 1 false))))))) in
     return (aR,ik,Dia,iR,oR)
  | JR (rs) ->
     let ik = IK_branch in
     let iR = (RFull (access GPRs (unsigned rs))) :: iR in
     let Dia = DIAFP_reg (RFull (access GPRs (unsigned rs))) in
     return (aR,ik,Dia,iR,oR)
  | JALR (rs,rd) ->
     let ik = IK_branch in
     let iR = (RFull (access GPRs (unsigned rs))) :: iR in
     let oR = (RFull "GPR31") :: oR in
     let Dia = DIAFP_reg (RFull (access GPRs (unsigned rs))) in
     return (aR,ik,Dia,iR,oR)
  | BEQ (rs,rd,imm,ne,likely) ->
     let ik = IK_branch in
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (rd, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rd))) :: iR in
     let offset =
       set_vector_start 63
         (add_VIV
            (reset_vector_start (set_vector_start_to_length
              (exts
                 ((64:ii),
                  reset_vector_start (set_vector_start_to_length
                    (imm ^^ (set_vector_start_to_length (Vector [B0;B0] 1 false))))))))
            (4:ii)) in
     read_reg PC >>= fun w__2 ->
     let Dia =
       DIAFP_concrete (reset_vector_start (set_vector_start 63
         (add_VVV w__2 (reset_vector_start (set_vector_start_to_length offset))))) in
     return (aR,ik,Dia,iR,oR)
  | BCMPZ (rs,imm,cmp,link,likely) ->
     let ik = IK_branch in
     let iR =
       if bitU_to_bool (eq_vec_range (rs, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rs))) :: iR in
     let oR = if bitU_to_bool link then (RFull "GPR31") :: oR else oR in
     let offset =
       set_vector_start 63
         (add_VIV
            (reset_vector_start (set_vector_start_to_length
              (exts
                 ((64:ii),
                  reset_vector_start (set_vector_start_to_length
                    (imm ^^ (set_vector_start_to_length (Vector [B0;B0] 1 false))))))))
            (4:ii)) in
     read_reg PC >>= fun w__3 ->
     let Dia =
       DIAFP_concrete (reset_vector_start (set_vector_start 63
         (add_VVV w__3 (reset_vector_start (set_vector_start_to_length offset))))) in
     return (aR,ik,Dia,iR,oR)
  | SYSCALL_THREAD_START -> return (aR,ik,Dia,iR,oR)
  | Load (width,signed,linked,base,rt,offset) ->
     let ik = IK_mem_read (if bitU_to_bool linked then Read_reserve else Read_plain) in
     let oR = if bitU_to_bool linked then (RFull "CP0LLBit") :: (RFull "CP0LLAddr") :: oR else oR in
     let aR =
       if bitU_to_bool (eq_vec_range (base, (0:ii)))
       then aR
       else (RFull (access GPRs (unsigned base))) :: aR in
     let iR = aR in
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | Store (width,conditional,base,rt,offset) ->
     let ik = IK_mem_write (if bitU_to_bool conditional then Write_conditional else Write_plain) in
     let aR =
       if bitU_to_bool (eq_vec_range (base, (0:ii)))
       then aR
       else (RFull (access GPRs (unsigned base))) :: aR in
     let iR = aR in
     let iR = if bitU_to_bool conditional then (RFull "CP0LLBit") :: iR else iR in
     let oR =
       if bitU_to_bool (conditional &. (neq_vec_range (rt, (0:ii))))
       then (RFull (access GPRs (unsigned rt))) :: oR
       else oR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     return (aR,ik,Dia,iR,oR)
  | LWL (base,rt,offset) ->
     let ik = IK_mem_read Read_plain in
     let aR =
       if bitU_to_bool (eq_vec_range (base, (0:ii)))
       then aR
       else (RFull (access GPRs (unsigned base))) :: aR in
     let iR = aR in
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | LWR (base,rt,offset) ->
     let ik = IK_mem_read Read_plain in
     let aR =
       if bitU_to_bool (eq_vec_range (base, (0:ii)))
       then aR
       else (RFull (access GPRs (unsigned base))) :: aR in
     let iR = aR in
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | SWL (base,rt,offset) ->
     let ik = IK_mem_write Write_plain in
     let aR =
       if bitU_to_bool (eq_vec_range (base, (0:ii)))
       then aR
       else (RFull (access GPRs (unsigned base))) :: aR in
     let iR = aR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     return (aR,ik,Dia,iR,oR)
  | SWR (base,rt,offset) ->
     let ik = IK_mem_write Write_plain in
     let aR =
       if bitU_to_bool (eq_vec_range (base, (0:ii)))
       then aR
       else (RFull (access GPRs (unsigned base))) :: aR in
     let iR = aR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     return (aR,ik,Dia,iR,oR)
  | LDL (base,rt,offset) ->
     let ik = IK_mem_read Read_plain in
     let aR =
       if bitU_to_bool (eq_vec_range (base, (0:ii)))
       then aR
       else (RFull (access GPRs (unsigned base))) :: aR in
     let iR = aR in
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | LDR (base,rt,offset) ->
     let ik = IK_mem_read Read_plain in
     let aR =
       if bitU_to_bool (eq_vec_range (base, (0:ii)))
       then aR
       else (RFull (access GPRs (unsigned base))) :: aR in
     let iR = aR in
     let oR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then oR
       else (RFull (access GPRs (unsigned rt))) :: oR in
     return (aR,ik,Dia,iR,oR)
  | SDL (base,rt,offset) ->
     let ik = IK_mem_write Write_plain in
     let aR =
       if bitU_to_bool (eq_vec_range (base, (0:ii)))
       then aR
       else (RFull (access GPRs (unsigned base))) :: aR in
     let iR = aR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     return (aR,ik,Dia,iR,oR)
  | SDR (base,rt,offset) ->
     let ik = IK_mem_write Write_plain in
     let aR =
       if bitU_to_bool (eq_vec_range (base, (0:ii)))
       then aR
       else (RFull (access GPRs (unsigned base))) :: aR in
     let iR = aR in
     let iR =
       if bitU_to_bool (eq_vec_range (rt, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned rt))) :: iR in
     return (aR,ik,Dia,iR,oR)
  | SYNC ->
     let iK = IK_barrier (Barrier_MIPS_SYNC) in
     return (aR,ik,Dia,iR,oR)
  end >>= fun (aR, ik, Dia, iR, oR) ->
  return (iR,oR,aR,Nias,Dia,ik)

let decode = function
  | ((Vector [B0;B1;B1;B0;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__0) ->
     let rs = slice_raw v__0 (6:ii) (10:ii) in
     let rt = slice_raw v__0 (11:ii) (15:ii) in
     let imm = slice_raw v__0 (16:ii) (31:ii) in
     Just (DADDIU (rs,rt,imm))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B1;B1;B0;B1] _ _) as v__2) ->
     let rs = slice_raw v__2 (6:ii) (10:ii) in
     let rt = slice_raw v__2 (11:ii) (15:ii) in
     let rd = slice_raw v__2 (16:ii) (20:ii) in
     Just (DADDU (rs,rt,rd))
  | ((Vector [B0;B1;B1;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__6) ->
     let rs = slice_raw v__6 (6:ii) (10:ii) in
     let rt = slice_raw v__6 (11:ii) (15:ii) in
     let imm = slice_raw v__6 (16:ii) (31:ii) in
     Just (DADDI (rs,rt,imm))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B1;B1;B0;B0] _ _) as v__8) ->
     let rs = slice_raw v__8 (6:ii) (10:ii) in
     let rt = slice_raw v__8 (11:ii) (15:ii) in
     let rd = slice_raw v__8 (16:ii) (20:ii) in
     Just (DADD (rs,rt,rd))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0] _ _) as v__12) ->
     let rs = slice_raw v__12 (6:ii) (10:ii) in
     let rt = slice_raw v__12 (11:ii) (15:ii) in
     let rd = slice_raw v__12 (16:ii) (20:ii) in
     Just (ADD (rs,rt,rd))
  | ((Vector [B0;B0;B1;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__16) ->
     let rs = slice_raw v__16 (6:ii) (10:ii) in
     let rt = slice_raw v__16 (11:ii) (15:ii) in
     let imm = slice_raw v__16 (16:ii) (31:ii) in
     Just (ADDI (rs,rt,imm))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1] _ _) as v__18) ->
     let rs = slice_raw v__18 (6:ii) (10:ii) in
     let rt = slice_raw v__18 (11:ii) (15:ii) in
     let rd = slice_raw v__18 (16:ii) (20:ii) in
     Just (ADDU (rs,rt,rd))
  | ((Vector [B0;B0;B1;B0;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__22) ->
     let rs = slice_raw v__22 (6:ii) (10:ii) in
     let rt = slice_raw v__22 (11:ii) (15:ii) in
     let imm = slice_raw v__22 (16:ii) (31:ii) in
     Just (ADDIU (rs,rt,imm))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B1;B1;B1;B1] _ _) as v__24) ->
     let rs = slice_raw v__24 (6:ii) (10:ii) in
     let rt = slice_raw v__24 (11:ii) (15:ii) in
     let rd = slice_raw v__24 (16:ii) (20:ii) in
     Just (DSUBU (rs,rt,rd))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B1;B1;B1;B0] _ _) as v__28) ->
     let rs = slice_raw v__28 (6:ii) (10:ii) in
     let rt = slice_raw v__28 (11:ii) (15:ii) in
     let rd = slice_raw v__28 (16:ii) (20:ii) in
     Just (DSUB (rs,rt,rd))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B0;B0;B1;B0] _ _) as v__32) ->
     let rs = slice_raw v__32 (6:ii) (10:ii) in
     let rt = slice_raw v__32 (11:ii) (15:ii) in
     let rd = slice_raw v__32 (16:ii) (20:ii) in
     Just (SUB (rs,rt,rd))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B0;B0;B1;B1] _ _) as v__36) ->
     let rs = slice_raw v__36 (6:ii) (10:ii) in
     let rt = slice_raw v__36 (11:ii) (15:ii) in
     let rd = slice_raw v__36 (16:ii) (20:ii) in
     Just (SUBU (rs,rt,rd))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B0;B1;B0;B0] _ _) as v__40) ->
     let rs = slice_raw v__40 (6:ii) (10:ii) in
     let rt = slice_raw v__40 (11:ii) (15:ii) in
     let rd = slice_raw v__40 (16:ii) (20:ii) in
     Just (AND (rs,rt,rd))
  | ((Vector [B0;B0;B1;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__44) ->
     let rs = slice_raw v__44 (6:ii) (10:ii) in
     let rt = slice_raw v__44 (11:ii) (15:ii) in
     let imm = slice_raw v__44 (16:ii) (31:ii) in
     Just (ANDI (rs,rt,imm))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B0;B1;B0;B1] _ _) as v__46) ->
     let rs = slice_raw v__46 (6:ii) (10:ii) in
     let rt = slice_raw v__46 (11:ii) (15:ii) in
     let rd = slice_raw v__46 (16:ii) (20:ii) in
     Just (OR (rs,rt,rd))
  | ((Vector [B0;B0;B1;B1;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__50) ->
     let rs = slice_raw v__50 (6:ii) (10:ii) in
     let rt = slice_raw v__50 (11:ii) (15:ii) in
     let imm = slice_raw v__50 (16:ii) (31:ii) in
     Just (ORI (rs,rt,imm))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B0;B1;B1;B1] _ _) as v__52) ->
     let rs = slice_raw v__52 (6:ii) (10:ii) in
     let rt = slice_raw v__52 (11:ii) (15:ii) in
     let rd = slice_raw v__52 (16:ii) (20:ii) in
     Just (NOR (rs,rt,rd))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B0;B1;B1;B0] _ _) as v__56) ->
     let rs = slice_raw v__56 (6:ii) (10:ii) in
     let rt = slice_raw v__56 (11:ii) (15:ii) in
     let rd = slice_raw v__56 (16:ii) (20:ii) in
     Just (XOR (rs,rt,rd))
  | ((Vector [B0;B0;B1;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__60) ->
     let rs = slice_raw v__60 (6:ii) (10:ii) in
     let rt = slice_raw v__60 (11:ii) (15:ii) in
     let imm = slice_raw v__60 (16:ii) (31:ii) in
     Just (XORI (rs,rt,imm))
  | ((Vector [B0;B0;B1;B1;B1;B1;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__62) ->
     let rt = slice_raw v__62 (11:ii) (15:ii) in
     let imm = slice_raw v__62 (16:ii) (31:ii) in
     Just (LUI (rt,imm))
  | ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B1;B0;B0;B0] _ _) as v__65) ->
     let rt = slice_raw v__65 (11:ii) (15:ii) in
     let rd = slice_raw v__65 (16:ii) (20:ii) in
     let sa = slice_raw v__65 (21:ii) (25:ii) in
     Just (DSLL (rt,rd,reset_vector_start sa))
  | ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B1;B1;B0;B0] _ _) as v__69) ->
     let rt = slice_raw v__69 (11:ii) (15:ii) in
     let rd = slice_raw v__69 (16:ii) (20:ii) in
     let sa = slice_raw v__69 (21:ii) (25:ii) in
     Just (DSLL32 (rt,rd,reset_vector_start sa))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B1;B0;B1;B0;B0] _ _) as v__73) ->
     let rs = slice_raw v__73 (6:ii) (10:ii) in
     let rt = slice_raw v__73 (11:ii) (15:ii) in
     let rd = slice_raw v__73 (16:ii) (20:ii) in
     Just (DSLLV (rs,rt,rd))
  | ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B1;B0;B1;B1] _ _) as v__77) ->
     let rt = slice_raw v__77 (11:ii) (15:ii) in
     let rd = slice_raw v__77 (16:ii) (20:ii) in
     let sa = slice_raw v__77 (21:ii) (25:ii) in
     Just (DSRA (rt,rd,reset_vector_start sa))
  | ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B1;B1;B1;B1] _ _) as v__81) ->
     let rt = slice_raw v__81 (11:ii) (15:ii) in
     let rd = slice_raw v__81 (16:ii) (20:ii) in
     let sa = slice_raw v__81 (21:ii) (25:ii) in
     Just (DSRA32 (rt,rd,reset_vector_start sa))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B1;B0;B1;B1;B1] _ _) as v__85) ->
     let rs = slice_raw v__85 (6:ii) (10:ii) in
     let rt = slice_raw v__85 (11:ii) (15:ii) in
     let rd = slice_raw v__85 (16:ii) (20:ii) in
     Just (DSRAV (rs,rt,rd))
  | ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B1;B0;B1;B0] _ _) as v__89) ->
     let rt = slice_raw v__89 (11:ii) (15:ii) in
     let rd = slice_raw v__89 (16:ii) (20:ii) in
     let sa = slice_raw v__89 (21:ii) (25:ii) in
     Just (DSRL (rt,rd,reset_vector_start sa))
  | ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B1;B1;B1;B0] _ _) as v__93) ->
     let rt = slice_raw v__93 (11:ii) (15:ii) in
     let rd = slice_raw v__93 (16:ii) (20:ii) in
     let sa = slice_raw v__93 (21:ii) (25:ii) in
     Just (DSRL32 (rt,rd,reset_vector_start sa))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B1;B0;B1;B1;B0] _ _) as v__97) ->
     let rs = slice_raw v__97 (6:ii) (10:ii) in
     let rt = slice_raw v__97 (11:ii) (15:ii) in
     let rd = slice_raw v__97 (16:ii) (20:ii) in
     Just (DSRLV (rs,rt,rd))
  | ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0] _ _) as v__101) ->
     let rt = slice_raw v__101 (11:ii) (15:ii) in
     let rd = slice_raw v__101 (16:ii) (20:ii) in
     let sa = slice_raw v__101 (21:ii) (25:ii) in
     Just (SLL (rt,rd,sa))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0] _ _) as v__105) ->
     let rs = slice_raw v__105 (6:ii) (10:ii) in
     let rt = slice_raw v__105 (11:ii) (15:ii) in
     let rd = slice_raw v__105 (16:ii) (20:ii) in
     Just (SLLV (rs,rt,rd))
  | ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B1;B1] _ _) as v__109) ->
     let rt = slice_raw v__109 (11:ii) (15:ii) in
     let rd = slice_raw v__109 (16:ii) (20:ii) in
     let sa = slice_raw v__109 (21:ii) (25:ii) in
     Just (SRA (rt,rd,sa))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1] _ _) as v__113) ->
     let rs = slice_raw v__113 (6:ii) (10:ii) in
     let rt = slice_raw v__113 (11:ii) (15:ii) in
     let rd = slice_raw v__113 (16:ii) (20:ii) in
     Just (SRAV (rs,rt,rd))
  | ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B1;B0] _ _) as v__117) ->
     let rt = slice_raw v__117 (11:ii) (15:ii) in
     let rd = slice_raw v__117 (16:ii) (20:ii) in
     let sa = slice_raw v__117 (21:ii) (25:ii) in
     Just (SRL (rt,rd,sa))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B0] _ _) as v__121) ->
     let rs = slice_raw v__121 (6:ii) (10:ii) in
     let rt = slice_raw v__121 (11:ii) (15:ii) in
     let rd = slice_raw v__121 (16:ii) (20:ii) in
     Just (SRLV (rs,rt,rd))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B1;B0;B1;B0] _ _) as v__125) ->
     let rs = slice_raw v__125 (6:ii) (10:ii) in
     let rt = slice_raw v__125 (11:ii) (15:ii) in
     let rd = slice_raw v__125 (16:ii) (20:ii) in
     Just (SLT (rs,rt,rd))
  | ((Vector [B0;B0;B1;B0;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__129) ->
     let rs = slice_raw v__129 (6:ii) (10:ii) in
     let rt = slice_raw v__129 (11:ii) (15:ii) in
     let imm = slice_raw v__129 (16:ii) (31:ii) in
     Just (SLTI (rs,rt,imm))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B1;B0;B1;B1] _ _) as v__131) ->
     let rs = slice_raw v__131 (6:ii) (10:ii) in
     let rt = slice_raw v__131 (11:ii) (15:ii) in
     let rd = slice_raw v__131 (16:ii) (20:ii) in
     Just (SLTU (rs,rt,rd))
  | ((Vector [B0;B0;B1;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__135) ->
     let rs = slice_raw v__135 (6:ii) (10:ii) in
     let rt = slice_raw v__135 (11:ii) (15:ii) in
     let imm = slice_raw v__135 (16:ii) (31:ii) in
     Just (SLTIU (rs,rt,imm))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B1;B0;B1;B1] _ _) as v__137) ->
     let rs = slice_raw v__137 (6:ii) (10:ii) in
     let rt = slice_raw v__137 (11:ii) (15:ii) in
     let rd = slice_raw v__137 (16:ii) (20:ii) in
     Just (MOVN (rs,rt,rd))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B1;B0;B1;B0] _ _) as v__141) ->
     let rs = slice_raw v__141 (6:ii) (10:ii) in
     let rt = slice_raw v__141 (11:ii) (15:ii) in
     let rd = slice_raw v__141 (16:ii) (20:ii) in
     Just (MOVZ (rs,rt,rd))
  | ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0] _ _) as v__145) ->
     let rd = slice_raw v__145 (16:ii) (20:ii) in
     Just (MFHI rd)
  | ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B1;B0;B0;B1;B0] _ _) as v__150) ->
     let rd = slice_raw v__150 (16:ii) (20:ii) in
     Just (MFLO rd)
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B1] _ _) as v__155) ->
     let rs = slice_raw v__155 (6:ii) (10:ii) in
     Just (MTHI rs)
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B1;B1] _ _) as v__159) ->
     let rs = slice_raw v__159 (6:ii) (10:ii) in
     Just (MTLO rs)
  | ((Vector [B0;B1;B1;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0] _ _) as v__163) ->
     let rs = slice_raw v__163 (6:ii) (10:ii) in
     let rt = slice_raw v__163 (11:ii) (15:ii) in
     let rd = slice_raw v__163 (16:ii) (20:ii) in
     Just (MUL (rs,rt,rd))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B0;B0;B0] _ _) as v__167) ->
     let rs = slice_raw v__167 (6:ii) (10:ii) in
     let rt = slice_raw v__167 (11:ii) (15:ii) in
     Just (MULT (rs,rt))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B0;B0;B1] _ _) as v__172) ->
     let rs = slice_raw v__172 (6:ii) (10:ii) in
     let rt = slice_raw v__172 (11:ii) (15:ii) in
     Just (MULTU (rs,rt))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B0;B0] _ _) as v__177) ->
     let rs = slice_raw v__177 (6:ii) (10:ii) in
     let rt = slice_raw v__177 (11:ii) (15:ii) in
     Just (DMULT (rs,rt))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B0;B1] _ _) as v__182) ->
     let rs = slice_raw v__182 (6:ii) (10:ii) in
     let rt = slice_raw v__182 (11:ii) (15:ii) in
     Just (DMULTU (rs,rt))
  | ((Vector [B0;B1;B1;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] _ _) as v__187) ->
     let rs = slice_raw v__187 (6:ii) (10:ii) in
     let rt = slice_raw v__187 (11:ii) (15:ii) in
     Just (MADD (rs,rt))
  | ((Vector [B0;B1;B1;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1] _ _) as v__192) ->
     let rs = slice_raw v__192 (6:ii) (10:ii) in
     let rt = slice_raw v__192 (11:ii) (15:ii) in
     Just (MADDU (rs,rt))
  | ((Vector [B0;B1;B1;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0] _ _) as v__197) ->
     let rs = slice_raw v__197 (6:ii) (10:ii) in
     let rt = slice_raw v__197 (11:ii) (15:ii) in
     Just (MSUB (rs,rt))
  | ((Vector [B0;B1;B1;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B1] _ _) as v__202) ->
     let rs = slice_raw v__202 (6:ii) (10:ii) in
     let rt = slice_raw v__202 (11:ii) (15:ii) in
     Just (MSUBU (rs,rt))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B0;B1;B0] _ _) as v__207) ->
     let rs = slice_raw v__207 (6:ii) (10:ii) in
     let rt = slice_raw v__207 (11:ii) (15:ii) in
     Just (DIV (rs,rt))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B0;B1;B1] _ _) as v__212) ->
     let rs = slice_raw v__212 (6:ii) (10:ii) in
     let rt = slice_raw v__212 (11:ii) (15:ii) in
     Just (DIVU (rs,rt))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1;B0] _ _) as v__217) ->
     let rs = slice_raw v__217 (6:ii) (10:ii) in
     let rt = slice_raw v__217 (11:ii) (15:ii) in
     Just (DDIV (rs,rt))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1;B1] _ _) as v__222) ->
     let rs = slice_raw v__222 (6:ii) (10:ii) in
     let rt = slice_raw v__222 (11:ii) (15:ii) in
     Just (DDIVU (rs,rt))
  | ((Vector [B0;B0;B0;B0;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__227) ->
     let offset = slice_raw v__227 (6:ii) (31:ii) in
     Just (J (reset_vector_start offset))
  | ((Vector [B0;B0;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__229) ->
     let offset = slice_raw v__229 (6:ii) (31:ii) in
     Just (JAL (reset_vector_start offset))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_;_;_;B0;B0;B1;B0;B0;B0] _ _) as v__231) ->
     let rs = slice_raw v__231 (6:ii) (10:ii) in
     let hint = slice_raw v__231 (21:ii) (25:ii) in
     Just (JR rs)
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B0;B1] _ _) as v__236) ->
     let rs = slice_raw v__236 (6:ii) (10:ii) in
     let rd = slice_raw v__236 (16:ii) (20:ii) in
     let hint = slice_raw v__236 (21:ii) (25:ii) in
     Just (JALR (rs,rd))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__240) ->
     let rs = slice_raw v__240 (6:ii) (10:ii) in
     let rt = slice_raw v__240 (11:ii) (15:ii) in
     let imm = slice_raw v__240 (16:ii) (31:ii) in
     Just (BEQ (rs,rt,imm,B0,B0))
  | ((Vector [B0;B1;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__242) ->
     let rs = slice_raw v__242 (6:ii) (10:ii) in
     let rt = slice_raw v__242 (11:ii) (15:ii) in
     let imm = slice_raw v__242 (16:ii) (31:ii) in
     Just (BEQ (rs,rt,imm,B0,B1))
  | ((Vector [B0;B0;B0;B1;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__244) ->
     let rs = slice_raw v__244 (6:ii) (10:ii) in
     let rt = slice_raw v__244 (11:ii) (15:ii) in
     let imm = slice_raw v__244 (16:ii) (31:ii) in
     Just (BEQ (rs,rt,imm,B1,B0))
  | ((Vector [B0;B1;B0;B1;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__246) ->
     let rs = slice_raw v__246 (6:ii) (10:ii) in
     let rt = slice_raw v__246 (11:ii) (15:ii) in
     let imm = slice_raw v__246 (16:ii) (31:ii) in
     Just (BEQ (rs,rt,imm,B1,B1))
  | ((Vector [B0;B0;B0;B0;B0;B1;_;_;_;_;_;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__248) ->
     let rs = slice_raw v__248 (6:ii) (10:ii) in
     let imm = slice_raw v__248 (16:ii) (31:ii) in
     Just (BCMPZ (rs,imm,LT',B0,B0))
  | ((Vector [B0;B0;B0;B0;B0;B1;_;_;_;_;_;B1;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__251) ->
     let rs = slice_raw v__251 (6:ii) (10:ii) in
     let imm = slice_raw v__251 (16:ii) (31:ii) in
     Just (BCMPZ (rs,imm,LT',B1,B0))
  | ((Vector [B0;B0;B0;B0;B0;B1;_;_;_;_;_;B0;B0;B0;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__254) ->
     let rs = slice_raw v__254 (6:ii) (10:ii) in
     let imm = slice_raw v__254 (16:ii) (31:ii) in
     Just (BCMPZ (rs,imm,LT',B0,B1))
  | ((Vector [B0;B0;B0;B0;B0;B1;_;_;_;_;_;B1;B0;B0;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__257) ->
     let rs = slice_raw v__257 (6:ii) (10:ii) in
     let imm = slice_raw v__257 (16:ii) (31:ii) in
     Just (BCMPZ (rs,imm,LT',B1,B1))
  | ((Vector [B0;B0;B0;B0;B0;B1;_;_;_;_;_;B0;B0;B0;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__260) ->
     let rs = slice_raw v__260 (6:ii) (10:ii) in
     let imm = slice_raw v__260 (16:ii) (31:ii) in
     Just (BCMPZ (rs,imm,GE,B0,B0))
  | ((Vector [B0;B0;B0;B0;B0;B1;_;_;_;_;_;B1;B0;B0;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__263) ->
     let rs = slice_raw v__263 (6:ii) (10:ii) in
     let imm = slice_raw v__263 (16:ii) (31:ii) in
     Just (BCMPZ (rs,imm,GE,B1,B0))
  | ((Vector [B0;B0;B0;B0;B0;B1;_;_;_;_;_;B0;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__266) ->
     let rs = slice_raw v__266 (6:ii) (10:ii) in
     let imm = slice_raw v__266 (16:ii) (31:ii) in
     Just (BCMPZ (rs,imm,GE,B0,B1))
  | ((Vector [B0;B0;B0;B0;B0;B1;_;_;_;_;_;B1;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__269) ->
     let rs = slice_raw v__269 (6:ii) (10:ii) in
     let imm = slice_raw v__269 (16:ii) (31:ii) in
     Just (BCMPZ (rs,imm,GE,B1,B1))
  | ((Vector [B0;B0;B0;B1;B1;B1;_;_;_;_;_;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__272) ->
     let rs = slice_raw v__272 (6:ii) (10:ii) in
     let imm = slice_raw v__272 (16:ii) (31:ii) in
     Just (BCMPZ (rs,imm,GT',B0,B0))
  | ((Vector [B0;B1;B0;B1;B1;B1;_;_;_;_;_;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__275) ->
     let rs = slice_raw v__275 (6:ii) (10:ii) in
     let imm = slice_raw v__275 (16:ii) (31:ii) in
     Just (BCMPZ (rs,imm,GT',B0,B1))
  | ((Vector [B0;B0;B0;B1;B1;B0;_;_;_;_;_;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__278) ->
     let rs = slice_raw v__278 (6:ii) (10:ii) in
     let imm = slice_raw v__278 (16:ii) (31:ii) in
     Just (BCMPZ (rs,imm,LE,B0,B0))
  | ((Vector [B0;B1;B0;B1;B1;B0;_;_;_;_;_;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__281) ->
     let rs = slice_raw v__281 (6:ii) (10:ii) in
     let imm = slice_raw v__281 (16:ii) (31:ii) in
     Just (BCMPZ (rs,imm,LE,B0,B1))
  | ((Vector [B0;B0;B0;B0;B0;B0;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B0;B0;B1;B1;B0;B0] _ _) as v__284) ->
     Just (SYSCALL_THREAD_START)
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B1;B0;B0] _ _) as v__288) ->
     let code = slice_raw v__288 (6:ii) (25:ii) in
     Just (SYSCALL)
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B1;B0;B1] _ _) as v__291) ->
     let code = slice_raw v__291 (6:ii) (25:ii) in
     Just (BREAK)
  | ((Vector [B0;B1;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0] _ _) as v__294) ->
     Just (WAIT)
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B0;B0;B0;B0] _ _) as v__298) ->
     let rs = slice_raw v__298 (6:ii) (10:ii) in
     let rt = slice_raw v__298 (11:ii) (15:ii) in
     let code = slice_raw v__298 (16:ii) (25:ii) in
     Just (TRAPREG (rs,rt,GE))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B0;B0;B0;B1] _ _) as v__301) ->
     let rs = slice_raw v__301 (6:ii) (10:ii) in
     let rt = slice_raw v__301 (11:ii) (15:ii) in
     let code = slice_raw v__301 (16:ii) (25:ii) in
     Just (TRAPREG (rs,rt,GEU))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B0;B0;B1;B0] _ _) as v__304) ->
     let rs = slice_raw v__304 (6:ii) (10:ii) in
     let rt = slice_raw v__304 (11:ii) (15:ii) in
     let code = slice_raw v__304 (16:ii) (25:ii) in
     Just (TRAPREG (rs,rt,LT'))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B0;B0;B1;B1] _ _) as v__307) ->
     let rs = slice_raw v__307 (6:ii) (10:ii) in
     let rt = slice_raw v__307 (11:ii) (15:ii) in
     let code = slice_raw v__307 (16:ii) (25:ii) in
     Just (TRAPREG (rs,rt,LTU))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B0;B1;B0;B0] _ _) as v__310) ->
     let rs = slice_raw v__310 (6:ii) (10:ii) in
     let rt = slice_raw v__310 (11:ii) (15:ii) in
     let code = slice_raw v__310 (16:ii) (25:ii) in
     Just (TRAPREG (rs,rt,EQ'))
  | ((Vector [B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B0;B1;B1;B0] _ _) as v__313) ->
     let rs = slice_raw v__313 (6:ii) (10:ii) in
     let rt = slice_raw v__313 (11:ii) (15:ii) in
     let code = slice_raw v__313 (16:ii) (25:ii) in
     Just (TRAPREG (rs,rt,NE))
  | ((Vector [B0;B0;B0;B0;B0;B1;_;_;_;_;_;B0;B1;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__316) ->
     let rs = slice_raw v__316 (6:ii) (10:ii) in
     let imm = slice_raw v__316 (16:ii) (31:ii) in
     Just (TRAPIMM (rs,imm,EQ'))
  | ((Vector [B0;B0;B0;B0;B0;B1;_;_;_;_;_;B0;B1;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__319) ->
     let rs = slice_raw v__319 (6:ii) (10:ii) in
     let imm = slice_raw v__319 (16:ii) (31:ii) in
     Just (TRAPIMM (rs,imm,NE))
  | ((Vector [B0;B0;B0;B0;B0;B1;_;_;_;_;_;B0;B1;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__322) ->
     let rs = slice_raw v__322 (6:ii) (10:ii) in
     let imm = slice_raw v__322 (16:ii) (31:ii) in
     Just (TRAPIMM (rs,imm,GE))
  | ((Vector [B0;B0;B0;B0;B0;B1;_;_;_;_;_;B0;B1;B0;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__325) ->
     let rs = slice_raw v__325 (6:ii) (10:ii) in
     let imm = slice_raw v__325 (16:ii) (31:ii) in
     Just (TRAPIMM (rs,imm,GEU))
  | ((Vector [B0;B0;B0;B0;B0;B1;_;_;_;_;_;B0;B1;B0;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__328) ->
     let rs = slice_raw v__328 (6:ii) (10:ii) in
     let imm = slice_raw v__328 (16:ii) (31:ii) in
     Just (TRAPIMM (rs,imm,LT'))
  | ((Vector [B0;B0;B0;B0;B0;B1;_;_;_;_;_;B0;B1;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__331) ->
     let rs = slice_raw v__331 (6:ii) (10:ii) in
     let imm = slice_raw v__331 (16:ii) (31:ii) in
     Just (TRAPIMM (rs,imm,LTU))
  | ((Vector [B1;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__334) ->
     let base = slice_raw v__334 (6:ii) (10:ii) in
     let rt = slice_raw v__334 (11:ii) (15:ii) in
     let offset = slice_raw v__334 (16:ii) (31:ii) in
     Just (Load (B,B1,B0,base,rt,offset))
  | ((Vector [B1;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__336) ->
     let base = slice_raw v__336 (6:ii) (10:ii) in
     let rt = slice_raw v__336 (11:ii) (15:ii) in
     let offset = slice_raw v__336 (16:ii) (31:ii) in
     Just (Load (B,B0,B0,base,rt,offset))
  | ((Vector [B1;B0;B0;B0;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__338) ->
     let base = slice_raw v__338 (6:ii) (10:ii) in
     let rt = slice_raw v__338 (11:ii) (15:ii) in
     let offset = slice_raw v__338 (16:ii) (31:ii) in
     Just (Load (H,B1,B0,base,rt,offset))
  | ((Vector [B1;B0;B0;B1;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__340) ->
     let base = slice_raw v__340 (6:ii) (10:ii) in
     let rt = slice_raw v__340 (11:ii) (15:ii) in
     let offset = slice_raw v__340 (16:ii) (31:ii) in
     Just (Load (H,B0,B0,base,rt,offset))
  | ((Vector [B1;B0;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__342) ->
     let base = slice_raw v__342 (6:ii) (10:ii) in
     let rt = slice_raw v__342 (11:ii) (15:ii) in
     let offset = slice_raw v__342 (16:ii) (31:ii) in
     Just (Load (W,B1,B0,base,rt,offset))
  | ((Vector [B1;B0;B0;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__344) ->
     let base = slice_raw v__344 (6:ii) (10:ii) in
     let rt = slice_raw v__344 (11:ii) (15:ii) in
     let offset = slice_raw v__344 (16:ii) (31:ii) in
     Just (Load (W,B0,B0,base,rt,offset))
  | ((Vector [B1;B1;B0;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__346) ->
     let base = slice_raw v__346 (6:ii) (10:ii) in
     let rt = slice_raw v__346 (11:ii) (15:ii) in
     let offset = slice_raw v__346 (16:ii) (31:ii) in
     Just (Load (D,B0,B0,base,rt,offset))
  | ((Vector [B1;B1;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__348) ->
     let base = slice_raw v__348 (6:ii) (10:ii) in
     let rt = slice_raw v__348 (11:ii) (15:ii) in
     let offset = slice_raw v__348 (16:ii) (31:ii) in
     Just (Load (W,B1,B1,base,rt,offset))
  | ((Vector [B1;B1;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__350) ->
     let base = slice_raw v__350 (6:ii) (10:ii) in
     let rt = slice_raw v__350 (11:ii) (15:ii) in
     let offset = slice_raw v__350 (16:ii) (31:ii) in
     Just (Load (D,B0,B1,base,rt,offset))
  | ((Vector [B1;B0;B1;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__352) ->
     let base = slice_raw v__352 (6:ii) (10:ii) in
     let rt = slice_raw v__352 (11:ii) (15:ii) in
     let offset = slice_raw v__352 (16:ii) (31:ii) in
     Just (Store (B,B0,base,rt,offset))
  | ((Vector [B1;B0;B1;B0;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__354) ->
     let base = slice_raw v__354 (6:ii) (10:ii) in
     let rt = slice_raw v__354 (11:ii) (15:ii) in
     let offset = slice_raw v__354 (16:ii) (31:ii) in
     Just (Store (H,B0,base,rt,offset))
  | ((Vector [B1;B0;B1;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__356) ->
     let base = slice_raw v__356 (6:ii) (10:ii) in
     let rt = slice_raw v__356 (11:ii) (15:ii) in
     let offset = slice_raw v__356 (16:ii) (31:ii) in
     Just (Store (W,B0,base,rt,offset))
  | ((Vector [B1;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__358) ->
     let base = slice_raw v__358 (6:ii) (10:ii) in
     let rt = slice_raw v__358 (11:ii) (15:ii) in
     let offset = slice_raw v__358 (16:ii) (31:ii) in
     Just (Store (D,B0,base,rt,offset))
  | ((Vector [B1;B1;B1;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__360) ->
     let base = slice_raw v__360 (6:ii) (10:ii) in
     let rt = slice_raw v__360 (11:ii) (15:ii) in
     let offset = slice_raw v__360 (16:ii) (31:ii) in
     Just (Store (W,B1,base,rt,offset))
  | ((Vector [B1;B1;B1;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__362) ->
     let base = slice_raw v__362 (6:ii) (10:ii) in
     let rt = slice_raw v__362 (11:ii) (15:ii) in
     let offset = slice_raw v__362 (16:ii) (31:ii) in
     Just (Store (D,B1,base,rt,offset))
  | ((Vector [B1;B0;B0;B0;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__364) ->
     let base = slice_raw v__364 (6:ii) (10:ii) in
     let rt = slice_raw v__364 (11:ii) (15:ii) in
     let offset = slice_raw v__364 (16:ii) (31:ii) in
     Just (LWL (base,rt,offset))
  | ((Vector [B1;B0;B0;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__366) ->
     let base = slice_raw v__366 (6:ii) (10:ii) in
     let rt = slice_raw v__366 (11:ii) (15:ii) in
     let offset = slice_raw v__366 (16:ii) (31:ii) in
     Just (LWR (base,rt,offset))
  | ((Vector [B1;B0;B1;B0;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__368) ->
     let base = slice_raw v__368 (6:ii) (10:ii) in
     let rt = slice_raw v__368 (11:ii) (15:ii) in
     let offset = slice_raw v__368 (16:ii) (31:ii) in
     Just (SWL (base,rt,offset))
  | ((Vector [B1;B0;B1;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__370) ->
     let base = slice_raw v__370 (6:ii) (10:ii) in
     let rt = slice_raw v__370 (11:ii) (15:ii) in
     let offset = slice_raw v__370 (16:ii) (31:ii) in
     Just (SWR (base,rt,offset))
  | ((Vector [B0;B1;B1;B0;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__372) ->
     let base = slice_raw v__372 (6:ii) (10:ii) in
     let rt = slice_raw v__372 (11:ii) (15:ii) in
     let offset = slice_raw v__372 (16:ii) (31:ii) in
     Just (LDL (base,rt,offset))
  | ((Vector [B0;B1;B1;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__374) ->
     let base = slice_raw v__374 (6:ii) (10:ii) in
     let rt = slice_raw v__374 (11:ii) (15:ii) in
     let offset = slice_raw v__374 (16:ii) (31:ii) in
     Just (LDR (base,rt,offset))
  | ((Vector [B1;B0;B1;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__376) ->
     let base = slice_raw v__376 (6:ii) (10:ii) in
     let rt = slice_raw v__376 (11:ii) (15:ii) in
     let offset = slice_raw v__376 (16:ii) (31:ii) in
     Just (SDL (base,rt,offset))
  | ((Vector [B1;B0;B1;B1;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__378) ->
     let base = slice_raw v__378 (6:ii) (10:ii) in
     let rt = slice_raw v__378 (11:ii) (15:ii) in
     let offset = slice_raw v__378 (16:ii) (31:ii) in
     Just (SDR (base,rt,offset))
  | ((Vector [B1;B0;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__380) ->
     let base = slice_raw v__380 (6:ii) (10:ii) in
     let op = slice_raw v__380 (11:ii) (15:ii) in
     let imm = slice_raw v__380 (16:ii) (31:ii) in
     Just (CACHE (base,op,imm))
  | ((Vector [B1;B1;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as v__382) ->
     let base = slice_raw v__382 (6:ii) (10:ii) in
     let op = slice_raw v__382 (11:ii) (15:ii) in
     let imm = slice_raw v__382 (16:ii) (31:ii) in
     Just (PREF (base,op,imm))
  | ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_;_;_;B0;B0;B1;B1;B1;B1] _ _) as v__384) ->
     let stype = slice_raw v__384 (21:ii) (25:ii) in
     Just (SYNC)
  | ((Vector [B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_] _ _) as v__390) ->
     let rt = slice_raw v__390 (11:ii) (15:ii) in
     let rd = slice_raw v__390 (16:ii) (20:ii) in
     let sel = slice_raw v__390 (29:ii) (31:ii) in
     Just (MFC0 (rt,rd,reset_vector_start sel,B0))
  | ((Vector [B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_] _ _) as v__394) ->
     let rt = slice_raw v__394 (11:ii) (15:ii) in
     let rd = slice_raw v__394 (16:ii) (20:ii) in
     let sel = slice_raw v__394 (29:ii) (31:ii) in
     Just (MFC0 (rt,rd,reset_vector_start sel,B1))
  | ((Vector [B0;B1;B0;B0;B0;B0;B0;B0;B1;B0;B0;_;_;_;_;_;B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] _ _) as v__398) ->
     let rt = slice_raw v__398 (11:ii) (15:ii) in
     Just (HCF)
  | ((Vector [B0;B1;B0;B0;B0;B0;B0;B0;B1;B0;B0;_;_;_;_;_;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] _ _) as v__403) ->
     let rt = slice_raw v__403 (11:ii) (15:ii) in
     Just (HCF)
  | ((Vector [B0;B1;B0;B0;B0;B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_] _ _) as v__408) ->
     let rt = slice_raw v__408 (11:ii) (15:ii) in
     let rd = slice_raw v__408 (16:ii) (20:ii) in
     let sel = slice_raw v__408 (29:ii) (31:ii) in
     Just (MTC0 (rt,rd,reset_vector_start sel,B0))
  | ((Vector [B0;B1;B0;B0;B0;B0;B0;B0;B1;B0;B1;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;_;_;_] _ _) as v__412) ->
     let rt = slice_raw v__412 (11:ii) (15:ii) in
     let rd = slice_raw v__412 (16:ii) (20:ii) in
     let sel = slice_raw v__412 (29:ii) (31:ii) in
     Just (MTC0 (rt,rd,reset_vector_start sel,B1))
  | ((Vector [B0;B1;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0] _ _) as v__416) ->
     Just (TLBWI)
  | ((Vector [B0;B1;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B0] _ _) as v__420) ->
     Just (TLBWR)
  | ((Vector [B0;B1;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1] _ _) as v__424) ->
     Just (TLBR)
  | ((Vector [B0;B1;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0] _ _) as v__428) ->
     Just (TLBP)
  | ((Vector [B0;B1;B1;B1;B1;B1;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B1;B1;B0;B1;B1] _ _) as v__432) ->
     let rt = slice_raw v__432 (11:ii) (15:ii) in
     let rd = slice_raw v__432 (16:ii) (20:ii) in
     Just (RDHWR (rt,rd))
  | ((Vector [B0;B1;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B0;B0;B0] _ _) as v__437) ->
     Just (ERET)
  end



let execute_DADDIU (rs, rt, imm) =
  rGPR rs >>= fun w__0 ->
  wGPR
    (rt,
     reset_vector_start (set_vector_start 63
       (add_VVV
          (reset_vector_start (set_vector_start_to_length w__0))
          (reset_vector_start (set_vector_start_to_length (exts ((64:ii),imm)))))))

let execute_DADDU (rs, rt, rd) =
  rGPR rs >>= fun w__0 ->
  rGPR rt >>= fun w__1 ->
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       (add_VVV
          (reset_vector_start (set_vector_start_to_length w__0))
          (reset_vector_start (set_vector_start_to_length w__1)))))

let execute_DADDI (rs, rt, imm) =
  rGPR rs >>= fun w__0 ->
  let sum65 =
    set_vector_start 64
      (add_VVV
         (reset_vector_start (set_vector_start_to_length
           (exts ((65:ii),reset_vector_start (set_vector_start_to_length w__0)))))
         (reset_vector_start (set_vector_start_to_length (exts ((65:ii),imm))))) in
  if bitU_to_bool (neq_bit (access sum65 (64:ii), access sum65 (63:ii)))
  then SignalException Ov
  else wGPR (rt,reset_vector_start (slice sum65 (63:ii) (0:ii)))

let execute_DADD (rs, rt, rd) =
  rGPR rs >>= fun w__0 ->
  rGPR rt >>= fun w__1 ->
  let sum65 =
    set_vector_start 64
      (add_VVV
         (reset_vector_start (set_vector_start_to_length
           (exts ((65:ii),reset_vector_start (set_vector_start_to_length w__0)))))
         (reset_vector_start (set_vector_start_to_length
           (exts ((65:ii),reset_vector_start (set_vector_start_to_length w__1)))))) in
  if bitU_to_bool (neq_bit (access sum65 (64:ii), access sum65 (63:ii)))
  then SignalException Ov
  else wGPR (rd,reset_vector_start (slice sum65 (63:ii) (0:ii)))

let execute_ADD (rs, rt, rd) =
  rGPR rs >>= fun opA ->
  rGPR rt >>= fun opB ->
  if bitU_to_bool ((NotWordVal (reset_vector_start opA)) |. (NotWordVal (reset_vector_start opB)))
  then wGPR (rd,reset_vector_start (to_vec_dec_undef (64:ii)))
  else
    let sum33 =
      set_vector_start 32
        (add_VVV
           (reset_vector_start (set_vector_start_to_length
             (exts
                ((33:ii),
                 reset_vector_start (set_vector_start_to_length (slice opA (31:ii) (0:ii)))))))
           (reset_vector_start (set_vector_start_to_length
             (exts
                ((33:ii),
                 reset_vector_start (set_vector_start_to_length (slice opB (31:ii) (0:ii)))))))) in
    if bitU_to_bool (neq_bit (access sum33 (32:ii), access sum33 (31:ii)))
    then SignalException Ov
    else
      wGPR
        (rd,
         reset_vector_start (set_vector_start 63
           (exts
              ((64:ii),
               reset_vector_start (set_vector_start_to_length (slice sum33 (31:ii) (0:ii)))))))

let execute_ADDI (rs, rt, imm) =
  rGPR rs >>= fun opA ->
  if bitU_to_bool (NotWordVal (reset_vector_start opA))
  then wGPR (rt,reset_vector_start (to_vec_dec_undef (64:ii)))
  else
    let sum33 =
      set_vector_start 32
        (add_VVV
           (reset_vector_start (set_vector_start_to_length
             (exts
                ((33:ii),
                 reset_vector_start (set_vector_start_to_length (slice opA (31:ii) (0:ii)))))))
           (reset_vector_start (set_vector_start_to_length (exts ((33:ii),imm))))) in
    if bitU_to_bool (neq_bit (access sum33 (32:ii), access sum33 (31:ii)))
    then SignalException Ov
    else
      wGPR
        (rt,
         reset_vector_start (set_vector_start 63
           (exts
              ((64:ii),
               reset_vector_start (set_vector_start_to_length (slice sum33 (31:ii) (0:ii)))))))

let execute_ADDU (rs, rt, rd) =
  rGPR rs >>= fun opA ->
  rGPR rt >>= fun opB ->
  if bitU_to_bool ((NotWordVal (reset_vector_start opA)) |. (NotWordVal (reset_vector_start opB)))
  then wGPR (rd,reset_vector_start (to_vec_dec_undef (64:ii)))
  else
    wGPR
      (rd,
       reset_vector_start (set_vector_start 63
         (exts
            ((64:ii),
             reset_vector_start (set_vector_start_to_length
               (add_VVV
                  (reset_vector_start (set_vector_start_to_length (slice opA (31:ii) (0:ii))))
                  (reset_vector_start (set_vector_start_to_length (slice opB (31:ii) (0:ii))))))))))

let execute_ADDIU (rs, rt, imm) =
  rGPR rs >>= fun opA ->
  if bitU_to_bool (NotWordVal (reset_vector_start opA))
  then wGPR (rt,reset_vector_start (to_vec_dec_undef (64:ii)))
  else
    wGPR
      (rt,
       reset_vector_start (set_vector_start 63
         (exts
            ((64:ii),
             reset_vector_start (set_vector_start_to_length
               (add_VVV
                  (reset_vector_start (set_vector_start_to_length (slice opA (31:ii) (0:ii))))
                  (reset_vector_start (set_vector_start_to_length
                    (exts (((31:ii) - (0:ii)) + (1:ii),imm))))))))))

let execute_DSUBU (rs, rt, rd) =
  rGPR rs >>= fun w__0 ->
  rGPR rt >>= fun w__1 ->
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       (minus_VVV
          (reset_vector_start (set_vector_start_to_length w__0))
          (reset_vector_start (set_vector_start_to_length w__1)))))

let execute_DSUB (rs, rt, rd) =
  rGPR rs >>= fun w__0 ->
  rGPR rt >>= fun w__1 ->
  let temp65 =
    set_vector_start 64
      (minus_VVV
         (reset_vector_start (set_vector_start_to_length
           (exts ((65:ii),reset_vector_start (set_vector_start_to_length w__0)))))
         (reset_vector_start (set_vector_start_to_length
           (exts ((65:ii),reset_vector_start (set_vector_start_to_length w__1)))))) in
  if bitU_to_bool (neq_bit (access temp65 (64:ii), access temp65 (63:ii)))
  then SignalException Ov
  else wGPR (rd,reset_vector_start (slice temp65 (63:ii) (0:ii)))

let execute_SUB (rs, rt, rd) =
  rGPR rs >>= fun opA ->
  rGPR rt >>= fun opB ->
  if bitU_to_bool ((NotWordVal (reset_vector_start opA)) |. (NotWordVal (reset_vector_start opB)))
  then wGPR (rd,reset_vector_start (to_vec_dec_undef (64:ii)))
  else
    let temp33 =
      set_vector_start 32
        (minus_VVV
           (reset_vector_start (set_vector_start_to_length
             (exts
                ((33:ii),
                 reset_vector_start (set_vector_start_to_length (slice opA (31:ii) (0:ii)))))))
           (reset_vector_start (set_vector_start_to_length
             (exts
                ((33:ii),
                 reset_vector_start (set_vector_start_to_length (slice opB (31:ii) (0:ii)))))))) in
    if bitU_to_bool (neq_bit (access temp33 (32:ii), access temp33 (31:ii)))
    then SignalException Ov
    else
      wGPR
        (rd,
         reset_vector_start (set_vector_start 63
           (exts
              ((64:ii),
               reset_vector_start (set_vector_start_to_length (slice temp33 (31:ii) (0:ii)))))))

let execute_SUBU (rs, rt, rd) =
  rGPR rs >>= fun opA ->
  rGPR rt >>= fun opB ->
  if bitU_to_bool ((NotWordVal (reset_vector_start opA)) |. (NotWordVal (reset_vector_start opB)))
  then wGPR (rd,reset_vector_start (to_vec_dec_undef (64:ii)))
  else
    wGPR
      (rd,
       reset_vector_start (set_vector_start 63
         (exts
            ((64:ii),
             reset_vector_start (set_vector_start_to_length
               (minus_VVV
                  (reset_vector_start (set_vector_start_to_length (slice opA (31:ii) (0:ii))))
                  (reset_vector_start (set_vector_start_to_length (slice opB (31:ii) (0:ii))))))))))

let execute_AND (rs, rt, rd) =
  rGPR rs >>= fun w__0 ->
  rGPR rt >>= fun w__1 ->
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       (bitwise_and (set_vector_start_to_length w__0, set_vector_start_to_length w__1))))

let execute_ANDI (rs, rt, imm) =
  rGPR rs >>= fun w__0 ->
  wGPR
    (rt,
     reset_vector_start (set_vector_start 63
       (bitwise_and
          (set_vector_start_to_length w__0,
          set_vector_start_to_length (extz ((64:ii),imm))))))

let execute_OR (rs, rt, rd) =
  rGPR rs >>= fun w__0 ->
  rGPR rt >>= fun w__1 ->
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       (bitwise_or (set_vector_start_to_length w__0, set_vector_start_to_length w__1))))

let execute_ORI (rs, rt, imm) =
  rGPR rs >>= fun w__0 ->
  wGPR
    (rt,
     reset_vector_start (set_vector_start 63
       (bitwise_or
          (set_vector_start_to_length w__0,
          set_vector_start_to_length (extz ((64:ii),imm))))))

let execute_NOR (rs, rt, rd) =
  rGPR rs >>= fun w__0 ->
  rGPR rt >>= fun w__1 ->
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       (bitwise_not
          (reset_vector_start (set_vector_start_to_length
            (bitwise_or (set_vector_start_to_length w__0, set_vector_start_to_length w__1)))))))

let execute_XOR (rs, rt, rd) =
  rGPR rs >>= fun w__0 ->
  rGPR rt >>= fun w__1 ->
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       (bitwise_xor (set_vector_start_to_length w__0, set_vector_start_to_length w__1))))

let execute_XORI (rs, rt, imm) =
  rGPR rs >>= fun w__0 ->
  wGPR
    (rt,
     reset_vector_start (set_vector_start 63
       (bitwise_xor
          (set_vector_start_to_length w__0,
          set_vector_start_to_length (extz ((64:ii),imm))))))

let execute_LUI (rt, imm) =
  wGPR
    (rt,
     reset_vector_start (set_vector_start 63
       (exts
          ((64:ii),
           reset_vector_start (set_vector_start_to_length
             (imm ^^
              (set_vector_start_to_length
                (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 15 false))))))))

let execute_DSLL (rt, rd, sa) =
  rGPR rt >>= fun w__0 ->
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       (bitwise_leftshift (set_vector_start_to_length w__0, unsigned sa))))

let execute_DSLL32 (rt, rd, sa) =
  rGPR rt >>= fun w__0 ->
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       (bitwise_leftshift
          (set_vector_start_to_length w__0,
          unsigned (reset_vector_start ((set_vector_start_to_length (Vector [B1] 0 false)) ^^ sa))))))

let execute_DSLLV (rs, rt, rd) =
  rGPR rt >>= fun w__0 ->
  rGPR rs >>= fun w__1 ->
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       (bitwise_leftshift
          (set_vector_start_to_length w__0,
          unsigned (reset_vector_start (slice (set_vector_start_to_length w__1) (5:ii) (0:ii)))))))

let execute_DSRA (rt, rd, sa) =
  rGPR rt >>= fun temp ->
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       ((set_vector_start_to_length (duplicate (access temp (63:ii), unsigned sa))) ^^
        (set_vector_start_to_length (slice temp (63:ii) (unsigned sa))))))

let execute_DSRA32 (rt, rd, sa) =
  rGPR rt >>= fun temp ->
  let sa32 = (set_vector_start_to_length (Vector [B1] 0 false)) ^^ sa in
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       ((set_vector_start_to_length
          (duplicate (access temp (63:ii), unsigned (reset_vector_start sa32)))) ^^
        (set_vector_start_to_length (slice temp (63:ii) (unsigned (reset_vector_start sa32)))))))

let execute_DSRAV (rs, rt, rd) =
  rGPR rt >>= fun temp ->
  rGPR rs >>= fun w__0 ->
  let sa = slice (set_vector_start_to_length w__0) (5:ii) (0:ii) in
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       ((set_vector_start_to_length
          (duplicate (access temp (63:ii), unsigned (reset_vector_start sa)))) ^^
        (set_vector_start_to_length (slice temp (63:ii) (unsigned (reset_vector_start sa)))))))

let execute_DSRL (rt, rd, sa) =
  rGPR rt >>= fun temp ->
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       ((set_vector_start_to_length (duplicate (B0, unsigned sa))) ^^
        (set_vector_start_to_length (slice temp (63:ii) (unsigned sa))))))

let execute_DSRL32 (rt, rd, sa) =
  rGPR rt >>= fun temp ->
  let sa32 = (set_vector_start_to_length (Vector [B1] 0 false)) ^^ sa in
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       ((set_vector_start_to_length (duplicate (B0, unsigned (reset_vector_start sa32)))) ^^
        (set_vector_start_to_length (slice temp (63:ii) (unsigned (reset_vector_start sa32)))))))

let execute_DSRLV (rs, rt, rd) =
  rGPR rt >>= fun temp ->
  rGPR rs >>= fun w__0 ->
  let sa = slice (set_vector_start_to_length w__0) (5:ii) (0:ii) in
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       ((set_vector_start_to_length (duplicate (B0, unsigned (reset_vector_start sa)))) ^^
        (set_vector_start_to_length (slice temp (63:ii) (unsigned (reset_vector_start sa)))))))

let execute_SLL (rt, rd, sa) =
  rGPR rt >>= fun w__0 ->
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       (exts
          ((64:ii),
           reset_vector_start (set_vector_start_to_length
             ((set_vector_start_to_length
                (slice (set_vector_start_to_length w__0) (minus_IVI (31:ii) sa) (0:ii))) ^^
              (set_vector_start_to_length (duplicate (B0, unsigned sa)))))))))

let execute_SLLV (rs, rt, rd) =
  rGPR rs >>= fun w__0 ->
  let sa = slice (set_vector_start_to_length w__0) (4:ii) (0:ii) in
  rGPR rt >>= fun w__1 ->
  wGPR
    (rd,
     reset_vector_start (set_vector_start 63
       (exts
          ((64:ii),
           reset_vector_start (set_vector_start_to_length
             ((set_vector_start_to_length
                (slice (set_vector_start_to_length w__1)
                   (minus_IVI (31:ii) (reset_vector_start (set_vector_start_to_length sa))) (0:ii))) ^^
              (set_vector_start_to_length (duplicate (B0, unsigned (reset_vector_start sa))))))))))

let execute_SRA (rt, rd, sa) =
  rGPR rt >>= fun temp ->
  if bitU_to_bool (NotWordVal (reset_vector_start temp))
  then wGPR (rd,reset_vector_start (to_vec_dec_undef (64:ii)))
  else
    wGPR
      (rd,
       reset_vector_start (set_vector_start 63
         ((set_vector_start_to_length (duplicate (access temp (31:ii), add_VII sa (32:ii)))) ^^
          (set_vector_start_to_length (slice temp (31:ii) (unsigned sa))))))

let execute_SRAV (rs, rt, rd) =
  rGPR rt >>= fun temp ->
  rGPR rs >>= fun w__0 ->
  let sa = slice (set_vector_start_to_length w__0) (4:ii) (0:ii) in
  if bitU_to_bool (NotWordVal (reset_vector_start temp))
  then wGPR (rd,reset_vector_start (to_vec_dec_undef (64:ii)))
  else
    wGPR
      (rd,
       reset_vector_start (set_vector_start 63
         ((set_vector_start_to_length
            (duplicate
               (access temp (31:ii),
               add_VII (reset_vector_start (set_vector_start_to_length sa)) (32:ii)))) ^^
          (set_vector_start_to_length (slice temp (31:ii) (unsigned (reset_vector_start sa)))))))

let execute_SRL (rt, rd, sa) =
  rGPR rt >>= fun temp ->
  if bitU_to_bool (NotWordVal (reset_vector_start temp))
  then wGPR (rd,reset_vector_start (to_vec_dec_undef (64:ii)))
  else
    wGPR
      (rd,
       reset_vector_start (set_vector_start 63
         (exts
            ((64:ii),
             reset_vector_start (set_vector_start_to_length
               ((set_vector_start_to_length (duplicate (B0, unsigned sa))) ^^
                (set_vector_start_to_length (slice temp (31:ii) (unsigned sa)))))))))

let execute_SRLV (rs, rt, rd) =
  rGPR rt >>= fun temp ->
  rGPR rs >>= fun w__0 ->
  let sa = slice (set_vector_start_to_length w__0) (4:ii) (0:ii) in
  if bitU_to_bool (NotWordVal (reset_vector_start temp))
  then wGPR (rd,reset_vector_start (to_vec_dec_undef (64:ii)))
  else
    wGPR
      (rd,
       reset_vector_start (set_vector_start 63
         (exts
            ((64:ii),
             reset_vector_start (set_vector_start_to_length
               ((set_vector_start_to_length (duplicate (B0, unsigned (reset_vector_start sa)))) ^^
                (set_vector_start_to_length (slice temp (31:ii) (unsigned (reset_vector_start sa))))))))))

let execute_SLT (rs, rt, rd) =
  rGPR rs >>= fun w__0 ->
  rGPR rt >>= fun w__1 ->
  wGPR
    (rd,
     reset_vector_start (if bitU_to_bool
                              (lt_vec_signed
                                 (set_vector_start_to_length w__0,
                                 set_vector_start_to_length w__1))
                         then to_vec_dec ((64:ii),(1:ii))
                         else to_vec_dec ((64:ii),(0:ii))))

let execute_SLTI (rs, rt, imm) =
  let imm_val = signed imm in
  rGPR rs >>= fun w__0 ->
  let rs_val = signed (reset_vector_start (set_vector_start_to_length w__0)) in
  wGPR
    (rt,
     reset_vector_start (if bitU_to_bool (lt (rs_val, imm_val))
                         then
                           Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                   B1] 63 false
                         else
                           Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                   B0] 63 false))

let execute_SLTU (rs, rt, rd) =
  rGPR rs >>= fun w__0 ->
  let rs_val =
    (set_vector_start_to_length (Vector [B0] 0 false)) ^^ (set_vector_start_to_length w__0) in
  rGPR rt >>= fun w__1 ->
  let rt_val =
    (set_vector_start_to_length (Vector [B0] 0 false)) ^^ (set_vector_start_to_length w__1) in
  wGPR
    (rd,
     reset_vector_start (if bitU_to_bool
                              (lt_vec
                                 (set_vector_start_to_length rs_val,
                                 set_vector_start_to_length rt_val))
                         then to_vec_dec ((64:ii),(1:ii))
                         else to_vec_dec ((64:ii),(0:ii))))

let execute_SLTIU (rs, rt, imm) =
  rGPR rs >>= fun w__0 ->
  let rs_val =
    (set_vector_start_to_length (Vector [B0] 0 false)) ^^ (set_vector_start_to_length w__0) in
  let imm_val =
    (set_vector_start_to_length (Vector [B0] 0 false)) ^^ (set_vector_start 63 (exts ((64:ii),imm))) in
  wGPR
    (rt,
     reset_vector_start (if bitU_to_bool
                              (lt_vec
                                 (set_vector_start_to_length rs_val,
                                 set_vector_start_to_length imm_val))
                         then to_vec_dec ((64:ii),(1:ii))
                         else to_vec_dec ((64:ii),(0:ii))))

let execute_MOVN (rs, rt, rd) =
  rGPR rt >>= fun w__0 ->
  if bitU_to_bool
       (neq_vec
          (set_vector_start_to_length w__0,
          set_vector_start_to_length
            (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0] 63 false)))
  then
    rGPR rs >>= fun w__1 ->
    wGPR (rd,reset_vector_start w__1)
  else return ()

let execute_MOVZ (rs, rt, rd) =
  rGPR rt >>= fun w__0 ->
  if bitU_to_bool
       (eq_vec
          (set_vector_start_to_length w__0,
          set_vector_start_to_length
            (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0] 63 false)))
  then
    rGPR rs >>= fun w__1 ->
    wGPR (rd,reset_vector_start w__1)
  else return ()

let execute_MFHI rd =
  read_reg HI >>= fun w__0 ->
  wGPR (rd,w__0)

let execute_MFLO rd =
  read_reg LO >>= fun w__0 ->
  wGPR (rd,w__0)

let execute_MTHI rs =
  rGPR rs >>= fun w__0 ->
  write_reg HI w__0

let execute_MTLO rs =
  rGPR rs >>= fun w__0 ->
  write_reg LO w__0

let execute_MUL (rs, rt, rd) =
  rGPR rs >>= fun rsVal ->
  rGPR rt >>= fun rtVal ->
  let result =
    set_vector_start 63
      (multS_VVV
         (reset_vector_start (set_vector_start_to_length (slice rsVal (31:ii) (0:ii))))
         (reset_vector_start (set_vector_start_to_length (slice rtVal (31:ii) (0:ii))))) in
  wGPR
    (rd,
     reset_vector_start (if bitU_to_bool
                              ((NotWordVal (reset_vector_start rsVal)) |.
                                 (NotWordVal (reset_vector_start rtVal)))
                         then to_vec_dec_undef (64:ii)
                         else
                           set_vector_start 63
                             (exts
                                ((64:ii),
                                 reset_vector_start (set_vector_start_to_length
                                   (slice result (31:ii) (0:ii)))))))

let execute_MULT (rs, rt) =
  rGPR rs >>= fun rsVal ->
  rGPR rt >>= fun rtVal ->
  let result =
    if bitU_to_bool
         ((NotWordVal (reset_vector_start rsVal)) |. (NotWordVal (reset_vector_start rtVal)))
    then to_vec_dec_undef (64:ii)
    else
      set_vector_start 63
        (multS_VVV
           (reset_vector_start (set_vector_start_to_length (slice rsVal (31:ii) (0:ii))))
           (reset_vector_start (set_vector_start_to_length (slice rtVal (31:ii) (0:ii))))) in
  write_reg
    HI
    (set_vector_start 63
      (exts ((64:ii),reset_vector_start (set_vector_start_to_length (slice result (63:ii) (32:ii)))))) >>
  write_reg
    LO
    (set_vector_start 63
      (exts ((64:ii),reset_vector_start (set_vector_start_to_length (slice result (31:ii) (0:ii))))))

let execute_MULTU (rs, rt) =
  rGPR rs >>= fun rsVal ->
  rGPR rt >>= fun rtVal ->
  let result =
    if bitU_to_bool
         ((NotWordVal (reset_vector_start rsVal)) |. (NotWordVal (reset_vector_start rtVal)))
    then to_vec_dec_undef (64:ii)
    else
      set_vector_start 63
        (mult_VVV
           (reset_vector_start (set_vector_start_to_length (slice rsVal (31:ii) (0:ii))))
           (reset_vector_start (set_vector_start_to_length (slice rtVal (31:ii) (0:ii))))) in
  write_reg
    HI
    (set_vector_start 63
      (exts ((64:ii),reset_vector_start (set_vector_start_to_length (slice result (63:ii) (32:ii)))))) >>
  write_reg
    LO
    (set_vector_start 63
      (exts ((64:ii),reset_vector_start (set_vector_start_to_length (slice result (31:ii) (0:ii))))))

let execute_DMULT (rs, rt) =
  rGPR rs >>= fun w__0 ->
  rGPR rt >>= fun w__1 ->
  let result =
    set_vector_start 127
      (multS_VVV
         (reset_vector_start (set_vector_start_to_length w__0))
         (reset_vector_start (set_vector_start_to_length w__1))) in
  write_reg HI (set_vector_start 63 (slice result (127:ii) (64:ii))) >>
  write_reg LO (slice result (63:ii) (0:ii))

let execute_DMULTU (rs, rt) =
  rGPR rs >>= fun w__0 ->
  rGPR rt >>= fun w__1 ->
  let result =
    set_vector_start 127
      (mult_VVV
         (reset_vector_start (set_vector_start_to_length w__0))
         (reset_vector_start (set_vector_start_to_length w__1))) in
  write_reg HI (set_vector_start 63 (slice result (127:ii) (64:ii))) >>
  write_reg LO (slice result (63:ii) (0:ii))

let execute_MADD (rs, rt) =
  rGPR rs >>= fun rsVal ->
  rGPR rt >>= fun rtVal ->
  let mul_result =
    if bitU_to_bool
         ((NotWordVal (reset_vector_start rsVal)) |. (NotWordVal (reset_vector_start rtVal)))
    then to_vec_dec_undef (64:ii)
    else
      set_vector_start 63
        (multS_VVV
           (reset_vector_start (set_vector_start_to_length (slice rsVal (31:ii) (0:ii))))
           (reset_vector_start (set_vector_start_to_length (slice rtVal (31:ii) (0:ii))))) in
  read_reg_range HI (31:ii) (0:ii) >>= fun w__0 ->
  read_reg_range LO (31:ii) (0:ii) >>= fun w__1 ->
  let result =
    set_vector_start 63
      (add_VVV
         (reset_vector_start (set_vector_start_to_length mul_result))
         (reset_vector_start (set_vector_start_to_length
           ((set_vector_start_to_length w__0) ^^ (set_vector_start_to_length w__1))))) in
  write_reg
    HI
    (set_vector_start 63
      (exts ((64:ii),reset_vector_start (set_vector_start_to_length (slice result (63:ii) (32:ii)))))) >>
  write_reg
    LO
    (set_vector_start 63
      (exts ((64:ii),reset_vector_start (set_vector_start_to_length (slice result (31:ii) (0:ii))))))

let execute_MADDU (rs, rt) =
  rGPR rs >>= fun rsVal ->
  rGPR rt >>= fun rtVal ->
  let mul_result =
    if bitU_to_bool
         ((NotWordVal (reset_vector_start rsVal)) |. (NotWordVal (reset_vector_start rtVal)))
    then to_vec_dec_undef (64:ii)
    else
      set_vector_start 63
        (mult_VVV
           (reset_vector_start (set_vector_start_to_length (slice rsVal (31:ii) (0:ii))))
           (reset_vector_start (set_vector_start_to_length (slice rtVal (31:ii) (0:ii))))) in
  read_reg_range HI (31:ii) (0:ii) >>= fun w__0 ->
  read_reg_range LO (31:ii) (0:ii) >>= fun w__1 ->
  let result =
    set_vector_start 63
      (add_VVV
         (reset_vector_start (set_vector_start_to_length mul_result))
         (reset_vector_start (set_vector_start_to_length
           ((set_vector_start_to_length w__0) ^^ (set_vector_start_to_length w__1))))) in
  write_reg
    HI
    (set_vector_start 63
      (exts ((64:ii),reset_vector_start (set_vector_start_to_length (slice result (63:ii) (32:ii)))))) >>
  write_reg
    LO
    (set_vector_start 63
      (exts ((64:ii),reset_vector_start (set_vector_start_to_length (slice result (31:ii) (0:ii))))))

let execute_MSUB (rs, rt) =
  rGPR rs >>= fun rsVal ->
  rGPR rt >>= fun rtVal ->
  let mul_result =
    if bitU_to_bool
         ((NotWordVal (reset_vector_start rsVal)) |. (NotWordVal (reset_vector_start rtVal)))
    then to_vec_dec_undef (64:ii)
    else
      set_vector_start 63
        (multS_VVV
           (reset_vector_start (set_vector_start_to_length (slice rsVal (31:ii) (0:ii))))
           (reset_vector_start (set_vector_start_to_length (slice rtVal (31:ii) (0:ii))))) in
  read_reg_range HI (31:ii) (0:ii) >>= fun w__0 ->
  read_reg_range LO (31:ii) (0:ii) >>= fun w__1 ->
  let result =
    set_vector_start 63
      (minus_VVV
         (reset_vector_start (set_vector_start_to_length
           ((set_vector_start_to_length w__0) ^^ (set_vector_start_to_length w__1))))
         (reset_vector_start (set_vector_start_to_length mul_result))) in
  write_reg
    HI
    (set_vector_start 63
      (exts ((64:ii),reset_vector_start (set_vector_start_to_length (slice result (63:ii) (32:ii)))))) >>
  write_reg
    LO
    (set_vector_start 63
      (exts ((64:ii),reset_vector_start (set_vector_start_to_length (slice result (31:ii) (0:ii))))))

let execute_MSUBU (rs, rt) =
  rGPR rs >>= fun rsVal ->
  rGPR rt >>= fun rtVal ->
  let mul_result =
    if bitU_to_bool
         ((NotWordVal (reset_vector_start rsVal)) |. (NotWordVal (reset_vector_start rtVal)))
    then to_vec_dec_undef (64:ii)
    else
      set_vector_start 63
        (mult_VVV
           (reset_vector_start (set_vector_start_to_length (slice rsVal (31:ii) (0:ii))))
           (reset_vector_start (set_vector_start_to_length (slice rtVal (31:ii) (0:ii))))) in
  read_reg_range HI (31:ii) (0:ii) >>= fun w__0 ->
  read_reg_range LO (31:ii) (0:ii) >>= fun w__1 ->
  let result =
    set_vector_start 63
      (minus_VVV
         (reset_vector_start (set_vector_start_to_length
           ((set_vector_start_to_length w__0) ^^ (set_vector_start_to_length w__1))))
         (reset_vector_start (set_vector_start_to_length mul_result))) in
  write_reg
    HI
    (set_vector_start 63
      (exts ((64:ii),reset_vector_start (set_vector_start_to_length (slice result (63:ii) (32:ii)))))) >>
  write_reg
    LO
    (set_vector_start 63
      (exts ((64:ii),reset_vector_start (set_vector_start_to_length (slice result (31:ii) (0:ii))))))

let execute_DIV (rs, rt) =
  rGPR rs >>= fun rsVal ->
  rGPR rt >>= fun rtVal ->
  let (q, r) =
    if bitU_to_bool
         ((NotWordVal (reset_vector_start rsVal)) |.
            ((NotWordVal (reset_vector_start rtVal)) |.
               (eq_vec_range (set_vector_start_to_length rtVal, (0:ii)))))
    then (to_vec_dec_undef (32:ii),to_vec_dec_undef (32:ii))
    else
      let si = signed (reset_vector_start (set_vector_start_to_length (slice rsVal (31:ii) (0:ii)))) in
      let ti = signed (reset_vector_start (set_vector_start_to_length (slice rtVal (31:ii) (0:ii)))) in
      let qi = quot si ti in
      let ri = si - (ti * qi) in
      (to_vec_dec ((32:ii),qi),to_vec_dec ((32:ii),ri)) in
  write_reg
    HI
    (set_vector_start 63 (exts ((64:ii),reset_vector_start (set_vector_start_to_length r)))) >>
  write_reg
    LO
    (set_vector_start 63 (exts ((64:ii),reset_vector_start (set_vector_start_to_length q))))

let execute_DIVU (rs, rt) =
  rGPR rs >>= fun rsVal ->
  rGPR rt >>= fun rtVal ->
  let (q, r) =
    if bitU_to_bool
         ((NotWordVal (reset_vector_start rsVal)) |.
            ((NotWordVal (reset_vector_start rtVal)) |.
               (eq_vec_range (set_vector_start_to_length rtVal, (0:ii)))))
    then (to_vec_dec_undef (32:ii),to_vec_dec_undef (32:ii))
    else
      let si =
        unsigned (reset_vector_start (set_vector_start_to_length (slice rsVal (31:ii) (0:ii)))) in
      let ti =
        unsigned (reset_vector_start (set_vector_start_to_length (slice rtVal (31:ii) (0:ii)))) in
      let qi = quot si ti in
      let ri = modulo si ti in
      (to_vec_dec ((32:ii),qi),to_vec_dec ((32:ii),ri)) in
  write_reg
    HI
    (set_vector_start 63 (exts ((64:ii),reset_vector_start (set_vector_start_to_length r)))) >>
  write_reg
    LO
    (set_vector_start 63 (exts ((64:ii),reset_vector_start (set_vector_start_to_length q))))

let execute_DDIV (rs, rt) =
  rGPR rs >>= fun w__0 ->
  let rsVal = signed (reset_vector_start (set_vector_start_to_length w__0)) in
  rGPR rt >>= fun w__1 ->
  let rtVal = signed (reset_vector_start (set_vector_start_to_length w__1)) in
  let (q, r) =
    if bitU_to_bool (eq_range (rtVal, (0:ii)))
    then (to_vec_dec_undef (64:ii),to_vec_dec_undef (64:ii))
    else
      let qi = quot rsVal rtVal in
      let ri = rsVal - (qi * rtVal) in
      (to_vec_dec ((64:ii),qi),to_vec_dec ((64:ii),ri)) in
  write_reg LO q >>
  write_reg HI r

let execute_DDIVU (rs, rt) =
  rGPR rs >>= fun w__0 ->
  let rsVal = unsigned (reset_vector_start w__0) in
  rGPR rt >>= fun w__1 ->
  let rtVal = unsigned (reset_vector_start w__1) in
  let (q, r) =
    if bitU_to_bool (eq_range (rtVal, (0:ii)))
    then (to_vec_dec_undef (64:ii),to_vec_dec_undef (64:ii))
    else
      let qi = quot rsVal rtVal in
      let ri = modulo rsVal rtVal in
      (to_vec_dec ((64:ii),qi),to_vec_dec ((64:ii),ri)) in
  write_reg LO q >>
  write_reg HI r

let execute_J offset =
  read_reg PC >>= fun w__0 ->
  write_reg
    delayedPC
    (set_vector_start 63
      ((set_vector_start_to_length
         (slice (set_vector_start_to_length (add_VIV w__0 (4:ii))) (63:ii) (28:ii))) ^^
       (set_vector_start_to_length
         ((set_vector_start_to_length offset) ^^
          (set_vector_start_to_length (Vector [B0;B0] 1 false)))))) >>
  write_reg branchPending (to_vec_dec ((1:ii),(1:ii)))

let execute_JAL offset =
  read_reg PC >>= fun w__0 ->
  write_reg
    delayedPC
    (set_vector_start 63
      ((set_vector_start_to_length
         (slice (set_vector_start_to_length (add_VIV w__0 (4:ii))) (63:ii) (28:ii))) ^^
       (set_vector_start_to_length
         ((set_vector_start_to_length offset) ^^
          (set_vector_start_to_length (Vector [B0;B0] 1 false)))))) >>
  write_reg branchPending (to_vec_dec ((1:ii),(1:ii))) >>
  read_reg PC >>= fun w__1 ->
  wGPR
    (reset_vector_start (to_vec_dec ((5:ii),(31:ii))),
     reset_vector_start (set_vector_start 63 (add_VIV w__1 (8:ii))))

let execute_JR rs =
  rGPR rs >>= fun w__0 ->
  write_reg delayedPC w__0 >>
  write_reg branchPending (to_vec_dec ((1:ii),(1:ii)))

let execute_JALR (rs, rd) =
  rGPR rs >>= fun w__0 ->
  write_reg delayedPC w__0 >>
  write_reg branchPending (to_vec_dec ((1:ii),(1:ii))) >>
  read_reg PC >>= fun w__1 ->
  wGPR (rd,reset_vector_start (set_vector_start 63 (add_VIV w__1 (8:ii))))

let execute_BEQ (rs, rd, imm, ne, likely) =
  rGPR rs >>= fun w__0 ->
  rGPR rd >>= fun w__1 ->
  if bitU_to_bool
       ((eq_vec (set_vector_start_to_length w__0, set_vector_start_to_length w__1)) +. ne)
  then
    let offset =
      set_vector_start 63
        (add_VIV
           (reset_vector_start (set_vector_start_to_length
             (exts
                ((64:ii),
                 reset_vector_start (set_vector_start_to_length
                   (imm ^^ (set_vector_start_to_length (Vector [B0;B0] 1 false))))))))
           (4:ii)) in
    read_reg PC >>= fun w__2 ->
    write_reg
      delayedPC
      (set_vector_start 63 (add_VVV w__2 (reset_vector_start (set_vector_start_to_length offset)))) >>
    write_reg branchPending (to_vec_dec ((1:ii),(1:ii)))
  else
    if bitU_to_bool likely
    then
      read_reg PC >>= fun w__3 ->
      write_reg nextPC (set_vector_start 63 (add_VIV w__3 (8:ii)))
    else return ()

let execute_BCMPZ (rs, imm, cmp, link, likely) =
  read_reg PC >>= fun w__0 ->
  let linkVal = set_vector_start 63 (add_VIV w__0 (8:ii)) in
  rGPR rs >>= fun regVal ->
  let condition =
    compare (cmp,reset_vector_start regVal,reset_vector_start (to_vec_dec ((64:ii),(0:ii)))) in
  (if bitU_to_bool condition
   then
     let offset =
       set_vector_start 63
         (add_VIV
            (reset_vector_start (set_vector_start_to_length
              (exts
                 ((64:ii),
                  reset_vector_start (set_vector_start_to_length
                    (imm ^^ (set_vector_start_to_length (Vector [B0;B0] 1 false))))))))
            (4:ii)) in
     read_reg PC >>= fun w__1 ->
     write_reg
       delayedPC
       (set_vector_start 63 (add_VVV w__1 (reset_vector_start (set_vector_start_to_length offset)))) >>
     write_reg branchPending (to_vec_dec ((1:ii),(1:ii)))
   else
     if bitU_to_bool likely
     then
       read_reg PC >>= fun w__2 ->
       write_reg nextPC (set_vector_start 63 (add_VIV w__2 (8:ii)))
     else return ()) >>
  if bitU_to_bool link
  then wGPR (reset_vector_start (to_vec_dec ((5:ii),(31:ii))),reset_vector_start linkVal)
  else return ()

let execute_SYSCALL_THREAD_START () = return ()

let execute_ImplementationDefinedStopFetching () = return ()

let execute_SYSCALL () = SignalException Sys

let execute_BREAK () = SignalException Bp

let execute_WAIT () =
  read_reg PC >>= fun w__0 ->
  write_reg nextPC w__0

let execute_TRAPREG (rs, rt, cmp) =
  rGPR rs >>= fun rs_val ->
  rGPR rt >>= fun rt_val ->
  let condition = compare (cmp,reset_vector_start rs_val,reset_vector_start rt_val) in
  if bitU_to_bool condition
  then SignalException Tr
  else return ()

let execute_TRAPIMM (rs, imm, cmp) =
  rGPR rs >>= fun rs_val ->
  let imm_val = exts ((64:ii),imm) in
  let condition =
    compare (cmp,reset_vector_start rs_val,reset_vector_start (set_vector_start 63 imm_val)) in
  if bitU_to_bool condition
  then SignalException Tr
  else return ()

let execute_Load (width, signed, linked, base, rt, offset) =
  rGPR base >>= fun w__0 ->
  let vAddr =
    addrWrapper
      (reset_vector_start (set_vector_start 63
         (add_VVV
            (reset_vector_start (set_vector_start_to_length (exts ((64:ii),offset))))
            (reset_vector_start (set_vector_start_to_length w__0)))),
       LoadData,
       width) in
  if bitU_to_bool (~(isAddressAligned (reset_vector_start vAddr,width)))
  then SignalExceptionBadAddr (AdEL,reset_vector_start vAddr)
  else
    let pAddr = TLBTranslate (reset_vector_start vAddr,LoadData) in
    (if bitU_to_bool linked
     then
       write_reg CP0LLBit (Vector [B1] 0 false) >>
       write_reg CP0LLAddr pAddr >>
       MEMr_reserve_wrapper (reset_vector_start pAddr,wordWidthBytes width)
     else MEMr_wrapper (reset_vector_start pAddr,wordWidthBytes width)) >>= fun memResult ->
    if bitU_to_bool signed
    then
      wGPR
        (rt,
         reset_vector_start (set_vector_start 63
           (exts ((64:ii),reset_vector_start (set_vector_start_to_length memResult)))))
    else
      wGPR
        (rt,
         reset_vector_start (set_vector_start 63
           (extz ((64:ii),reset_vector_start (set_vector_start_to_length memResult)))))

let execute_Store (width, conditional, base, rt, offset) =
  rGPR base >>= fun w__0 ->
  let vAddr =
    addrWrapper
      (reset_vector_start (set_vector_start 63
         (add_VVV
            (reset_vector_start (set_vector_start_to_length (exts ((64:ii),offset))))
            (reset_vector_start (set_vector_start_to_length w__0)))),
       StoreData,
       width) in
  rGPR rt >>= fun rt_val ->
  if bitU_to_bool (~(isAddressAligned (reset_vector_start vAddr,width)))
  then SignalExceptionBadAddr (AdES,reset_vector_start vAddr)
  else
    let pAddr = TLBTranslate (reset_vector_start vAddr,StoreData) in
    if bitU_to_bool conditional
    then
      read_reg_bit CP0LLBit (0:ii) >>= fun w__1 ->
      (if bitU_to_bool w__1
       then
         match width with
         | B ->
            MEMw_conditional_wrapper
              (reset_vector_start pAddr,
               (1:ii),
               reset_vector_start (set_vector_start_to_length (slice rt_val (7:ii) (0:ii))))
         | H ->
            MEMw_conditional_wrapper
              (reset_vector_start pAddr,
               (2:ii),
               reset_vector_start (set_vector_start_to_length (slice rt_val (15:ii) (0:ii))))
         | W ->
            MEMw_conditional_wrapper
              (reset_vector_start pAddr,
               (4:ii),
               reset_vector_start (set_vector_start_to_length (slice rt_val (31:ii) (0:ii))))
         | D ->
            MEMw_conditional_wrapper
              (reset_vector_start pAddr,
               (8:ii),
               reset_vector_start (set_vector_start_to_length rt_val))
         end
       else return B0) >>= fun success ->
      wGPR
        (rt,
         reset_vector_start (set_vector_start 63
           (extz
              ((64:ii),
               reset_vector_start (set_vector_start_to_length (Vector [success] 0 false))))))
    else
      match width with
      | B ->
         MEMw_wrapper
           (reset_vector_start pAddr,
            (1:ii),
            reset_vector_start (set_vector_start_to_length (slice rt_val (7:ii) (0:ii))))
      | H ->
         MEMw_wrapper
           (reset_vector_start pAddr,
            (2:ii),
            reset_vector_start (set_vector_start_to_length (slice rt_val (15:ii) (0:ii))))
      | W ->
         MEMw_wrapper
           (reset_vector_start pAddr,
            (4:ii),
            reset_vector_start (set_vector_start_to_length (slice rt_val (31:ii) (0:ii))))
      | D ->
         MEMw_wrapper
           (reset_vector_start pAddr,
            (8:ii),
            reset_vector_start (set_vector_start_to_length rt_val))
      end

let execute_LWL (base, rt, offset) =
  rGPR base >>= fun w__0 ->
  let vAddr =
    addrWrapper
      (reset_vector_start (set_vector_start 63
         (add_VVV
            (reset_vector_start (set_vector_start_to_length (exts ((64:ii),offset))))
            (reset_vector_start (set_vector_start_to_length w__0)))),
       LoadData,
       W) in
  let pAddr = TLBTranslate (reset_vector_start vAddr,LoadData) in
  MEMr_wrapper
    (reset_vector_start ((set_vector_start_to_length (slice pAddr (63:ii) (2:ii))) ^^
                         (set_vector_start_to_length (Vector [B0;B0] 1 false))),
     (4:ii)) >>= fun mem_val ->
  rGPR rt >>= fun reg_val ->
  wGPR
    (rt,
     reset_vector_start (set_vector_start 63
       (exts
          ((64:ii),
           reset_vector_start (match (slice vAddr (1:ii) (0:ii)) with
                               | Vector [B0;B0] _ _ -> set_vector_start_to_length mem_val
                               | Vector [B0;B1] _ _ ->
                                  set_vector_start_to_length
                                    ((set_vector_start_to_length
                                       (slice (set_vector_start_to_length mem_val) (23:ii) (0:ii))) ^^
                                     (set_vector_start_to_length (slice reg_val (7:ii) (0:ii))))
                               | Vector [B1;B0] _ _ ->
                                  set_vector_start_to_length
                                    ((set_vector_start_to_length
                                       (slice (set_vector_start_to_length mem_val) (15:ii) (0:ii))) ^^
                                     (set_vector_start_to_length (slice reg_val (15:ii) (0:ii))))
                               | Vector [B1;B1] _ _ ->
                                  set_vector_start_to_length
                                    ((set_vector_start_to_length
                                       (slice (set_vector_start_to_length mem_val) (7:ii) (0:ii))) ^^
                                     (set_vector_start_to_length (slice reg_val (23:ii) (0:ii))))
                               end)))))

let execute_LWR (base, rt, offset) =
  rGPR base >>= fun w__0 ->
  let vAddr =
    addrWrapper
      (reset_vector_start (set_vector_start 63
         (add_VVV
            (reset_vector_start (set_vector_start_to_length (exts ((64:ii),offset))))
            (reset_vector_start (set_vector_start_to_length w__0)))),
       LoadData,
       W) in
  let pAddr = TLBTranslate (reset_vector_start vAddr,LoadData) in
  MEMr_wrapper
    (reset_vector_start ((set_vector_start_to_length (slice pAddr (63:ii) (2:ii))) ^^
                         (set_vector_start_to_length (Vector [B0;B0] 1 false))),
     (4:ii)) >>= fun mem_val ->
  rGPR rt >>= fun reg_val ->
  wGPR
    (rt,
     reset_vector_start (set_vector_start 63
       (exts
          ((64:ii),
           reset_vector_start (match (slice vAddr (1:ii) (0:ii)) with
                               | Vector [B0;B0] _ _ ->
                                  set_vector_start_to_length
                                    ((set_vector_start_to_length (slice reg_val (31:ii) (8:ii))) ^^
                                     (set_vector_start_to_length
                                       (slice (set_vector_start_to_length mem_val) (31:ii) (24:ii))))
                               | Vector [B0;B1] _ _ ->
                                  set_vector_start_to_length
                                    ((set_vector_start_to_length (slice reg_val (31:ii) (16:ii))) ^^
                                     (set_vector_start_to_length
                                       (slice (set_vector_start_to_length mem_val) (31:ii) (16:ii))))
                               | Vector [B1;B0] _ _ ->
                                  set_vector_start_to_length
                                    ((set_vector_start_to_length (slice reg_val (31:ii) (24:ii))) ^^
                                     (set_vector_start_to_length
                                       (slice (set_vector_start_to_length mem_val) (31:ii) (8:ii))))
                               | Vector [B1;B1] _ _ -> set_vector_start_to_length mem_val
                               end)))))

let execute_SWL (base, rt, offset) =
  rGPR base >>= fun w__0 ->
  let vAddr =
    addrWrapper
      (reset_vector_start (set_vector_start 63
         (add_VVV
            (reset_vector_start (set_vector_start_to_length (exts ((64:ii),offset))))
            (reset_vector_start (set_vector_start_to_length w__0)))),
       StoreData,
       W) in
  let pAddr = TLBTranslate (reset_vector_start vAddr,StoreData) in
  rGPR rt >>= fun reg_val ->
  match (slice vAddr (1:ii) (0:ii)) with
  | Vector [B0;B0] _ _ ->
     MEMw_wrapper
       (reset_vector_start pAddr,
        (4:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (31:ii) (0:ii))))
  | Vector [B0;B1] _ _ ->
     MEMw_wrapper
       (reset_vector_start pAddr,
        (3:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (31:ii) (8:ii))))
  | Vector [B1;B0] _ _ ->
     MEMw_wrapper
       (reset_vector_start pAddr,
        (2:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (31:ii) (16:ii))))
  | Vector [B1;B1] _ _ ->
     MEMw_wrapper
       (reset_vector_start pAddr,
        (1:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (31:ii) (24:ii))))
  end

let execute_SWR (base, rt, offset) =
  rGPR base >>= fun w__0 ->
  let vAddr =
    addrWrapper
      (reset_vector_start (set_vector_start 63
         (add_VVV
            (reset_vector_start (set_vector_start_to_length (exts ((64:ii),offset))))
            (reset_vector_start (set_vector_start_to_length w__0)))),
       StoreData,
       W) in
  let pAddr = TLBTranslate (reset_vector_start vAddr,StoreData) in
  let wordAddr =
    (set_vector_start_to_length (slice pAddr (63:ii) (2:ii))) ^^
    (set_vector_start_to_length (Vector [B0;B0] 1 false)) in
  rGPR rt >>= fun reg_val ->
  match (slice vAddr (1:ii) (0:ii)) with
  | Vector [B0;B0] _ _ ->
     MEMw_wrapper
       (reset_vector_start wordAddr,
        (1:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (7:ii) (0:ii))))
  | Vector [B0;B1] _ _ ->
     MEMw_wrapper
       (reset_vector_start wordAddr,
        (2:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (15:ii) (0:ii))))
  | Vector [B1;B0] _ _ ->
     MEMw_wrapper
       (reset_vector_start wordAddr,
        (3:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (23:ii) (0:ii))))
  | Vector [B1;B1] _ _ ->
     MEMw_wrapper
       (reset_vector_start wordAddr,
        (4:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (31:ii) (0:ii))))
  end

let execute_LDL (base, rt, offset) =
  rGPR base >>= fun w__0 ->
  let vAddr =
    addrWrapper
      (reset_vector_start (set_vector_start 63
         (add_VVV
            (reset_vector_start (set_vector_start_to_length (exts ((64:ii),offset))))
            (reset_vector_start (set_vector_start_to_length w__0)))),
       LoadData,
       D) in
  let pAddr = TLBTranslate (reset_vector_start vAddr,StoreData) in
  MEMr_wrapper
    (reset_vector_start ((set_vector_start_to_length (slice pAddr (63:ii) (3:ii))) ^^
                         (set_vector_start_to_length (Vector [B0;B0;B0] 2 false))),
     (8:ii)) >>= fun mem_val ->
  rGPR rt >>= fun reg_val ->
  wGPR
    (rt,
     reset_vector_start (match (slice vAddr (2:ii) (0:ii)) with
                         | Vector [B0;B0;B0] _ _ -> set_vector_start 63 mem_val
                         | Vector [B0;B0;B1] _ _ ->
                            (set_vector_start_to_length
                              (slice (set_vector_start_to_length mem_val) (55:ii) (0:ii))) ^^
                            (set_vector_start_to_length (slice reg_val (7:ii) (0:ii)))
                         | Vector [B0;B1;B0] _ _ ->
                            (set_vector_start_to_length
                              (slice (set_vector_start_to_length mem_val) (47:ii) (0:ii))) ^^
                            (set_vector_start_to_length (slice reg_val (15:ii) (0:ii)))
                         | Vector [B0;B1;B1] _ _ ->
                            (set_vector_start_to_length
                              (slice (set_vector_start_to_length mem_val) (39:ii) (0:ii))) ^^
                            (set_vector_start_to_length (slice reg_val (23:ii) (0:ii)))
                         | Vector [B1;B0;B0] _ _ ->
                            (set_vector_start_to_length
                              (slice (set_vector_start_to_length mem_val) (31:ii) (0:ii))) ^^
                            (set_vector_start_to_length (slice reg_val (31:ii) (0:ii)))
                         | Vector [B1;B0;B1] _ _ ->
                            (set_vector_start_to_length
                              (slice (set_vector_start_to_length mem_val) (23:ii) (0:ii))) ^^
                            (set_vector_start_to_length (slice reg_val (39:ii) (0:ii)))
                         | Vector [B1;B1;B0] _ _ ->
                            (set_vector_start_to_length
                              (slice (set_vector_start_to_length mem_val) (15:ii) (0:ii))) ^^
                            (set_vector_start_to_length (slice reg_val (47:ii) (0:ii)))
                         | Vector [B1;B1;B1] _ _ ->
                            (set_vector_start_to_length
                              (slice (set_vector_start_to_length mem_val) (7:ii) (0:ii))) ^^
                            (set_vector_start_to_length (slice reg_val (55:ii) (0:ii)))
                         end))

let execute_LDR (base, rt, offset) =
  rGPR base >>= fun w__0 ->
  let vAddr =
    addrWrapper
      (reset_vector_start (set_vector_start 63
         (add_VVV
            (reset_vector_start (set_vector_start_to_length (exts ((64:ii),offset))))
            (reset_vector_start (set_vector_start_to_length w__0)))),
       LoadData,
       D) in
  let pAddr = TLBTranslate (reset_vector_start vAddr,StoreData) in
  MEMr_wrapper
    (reset_vector_start ((set_vector_start_to_length (slice pAddr (63:ii) (3:ii))) ^^
                         (set_vector_start_to_length (Vector [B0;B0;B0] 2 false))),
     (8:ii)) >>= fun mem_val ->
  rGPR rt >>= fun reg_val ->
  wGPR
    (rt,
     reset_vector_start (match (slice vAddr (2:ii) (0:ii)) with
                         | Vector [B0;B0;B0] _ _ ->
                            (set_vector_start_to_length (slice reg_val (63:ii) (8:ii))) ^^
                            (set_vector_start_to_length
                              (slice (set_vector_start_to_length mem_val) (63:ii) (56:ii)))
                         | Vector [B0;B0;B1] _ _ ->
                            (set_vector_start_to_length (slice reg_val (63:ii) (16:ii))) ^^
                            (set_vector_start_to_length
                              (slice (set_vector_start_to_length mem_val) (63:ii) (48:ii)))
                         | Vector [B0;B1;B0] _ _ ->
                            (set_vector_start_to_length (slice reg_val (63:ii) (24:ii))) ^^
                            (set_vector_start_to_length
                              (slice (set_vector_start_to_length mem_val) (63:ii) (40:ii)))
                         | Vector [B0;B1;B1] _ _ ->
                            (set_vector_start_to_length (slice reg_val (63:ii) (32:ii))) ^^
                            (set_vector_start_to_length
                              (slice (set_vector_start_to_length mem_val) (63:ii) (32:ii)))
                         | Vector [B1;B0;B0] _ _ ->
                            (set_vector_start_to_length (slice reg_val (63:ii) (40:ii))) ^^
                            (set_vector_start_to_length
                              (slice (set_vector_start_to_length mem_val) (63:ii) (24:ii)))
                         | Vector [B1;B0;B1] _ _ ->
                            (set_vector_start_to_length (slice reg_val (63:ii) (48:ii))) ^^
                            (set_vector_start_to_length
                              (slice (set_vector_start_to_length mem_val) (63:ii) (16:ii)))
                         | Vector [B1;B1;B0] _ _ ->
                            (set_vector_start_to_length (slice reg_val (63:ii) (56:ii))) ^^
                            (set_vector_start_to_length
                              (slice (set_vector_start_to_length mem_val) (63:ii) (8:ii)))
                         | Vector [B1;B1;B1] _ _ -> set_vector_start 63 mem_val
                         end))

let execute_SDL (base, rt, offset) =
  rGPR base >>= fun w__0 ->
  let vAddr =
    addrWrapper
      (reset_vector_start (set_vector_start 63
         (add_VVV
            (reset_vector_start (set_vector_start_to_length (exts ((64:ii),offset))))
            (reset_vector_start (set_vector_start_to_length w__0)))),
       StoreData,
       D) in
  let pAddr = TLBTranslate (reset_vector_start vAddr,StoreData) in
  rGPR rt >>= fun reg_val ->
  match (slice vAddr (2:ii) (0:ii)) with
  | Vector [B0;B0;B0] _ _ ->
     MEMw_wrapper
       (reset_vector_start pAddr,
        (8:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (63:ii) (0:ii))))
  | Vector [B0;B0;B1] _ _ ->
     MEMw_wrapper
       (reset_vector_start pAddr,
        (7:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (63:ii) (8:ii))))
  | Vector [B0;B1;B0] _ _ ->
     MEMw_wrapper
       (reset_vector_start pAddr,
        (6:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (63:ii) (16:ii))))
  | Vector [B0;B1;B1] _ _ ->
     MEMw_wrapper
       (reset_vector_start pAddr,
        (5:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (63:ii) (24:ii))))
  | Vector [B1;B0;B0] _ _ ->
     MEMw_wrapper
       (reset_vector_start pAddr,
        (4:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (63:ii) (32:ii))))
  | Vector [B1;B0;B1] _ _ ->
     MEMw_wrapper
       (reset_vector_start pAddr,
        (3:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (63:ii) (40:ii))))
  | Vector [B1;B1;B0] _ _ ->
     MEMw_wrapper
       (reset_vector_start pAddr,
        (2:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (63:ii) (48:ii))))
  | Vector [B1;B1;B1] _ _ ->
     MEMw_wrapper
       (reset_vector_start pAddr,
        (1:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (63:ii) (56:ii))))
  end

let execute_SDR (base, rt, offset) =
  rGPR base >>= fun w__0 ->
  let vAddr =
    addrWrapper
      (reset_vector_start (set_vector_start 63
         (add_VVV
            (reset_vector_start (set_vector_start_to_length (exts ((64:ii),offset))))
            (reset_vector_start (set_vector_start_to_length w__0)))),
       StoreData,
       D) in
  let pAddr = TLBTranslate (reset_vector_start vAddr,StoreData) in
  rGPR rt >>= fun reg_val ->
  let wordAddr =
    (set_vector_start_to_length (slice pAddr (63:ii) (3:ii))) ^^
    (set_vector_start_to_length (Vector [B0;B0;B0] 2 false)) in
  match (slice vAddr (2:ii) (0:ii)) with
  | Vector [B0;B0;B0] _ _ ->
     MEMw_wrapper
       (reset_vector_start wordAddr,
        (1:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (7:ii) (0:ii))))
  | Vector [B0;B0;B1] _ _ ->
     MEMw_wrapper
       (reset_vector_start wordAddr,
        (2:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (15:ii) (0:ii))))
  | Vector [B0;B1;B0] _ _ ->
     MEMw_wrapper
       (reset_vector_start wordAddr,
        (3:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (23:ii) (0:ii))))
  | Vector [B0;B1;B1] _ _ ->
     MEMw_wrapper
       (reset_vector_start wordAddr,
        (4:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (31:ii) (0:ii))))
  | Vector [B1;B0;B0] _ _ ->
     MEMw_wrapper
       (reset_vector_start wordAddr,
        (5:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (39:ii) (0:ii))))
  | Vector [B1;B0;B1] _ _ ->
     MEMw_wrapper
       (reset_vector_start wordAddr,
        (6:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (47:ii) (0:ii))))
  | Vector [B1;B1;B0] _ _ ->
     MEMw_wrapper
       (reset_vector_start wordAddr,
        (7:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (55:ii) (0:ii))))
  | Vector [B1;B1;B1] _ _ ->
     MEMw_wrapper
       (reset_vector_start wordAddr,
        (8:ii),
        reset_vector_start (set_vector_start_to_length (slice reg_val (63:ii) (0:ii))))
  end

let execute_CACHE (base, op, imm) = checkCP0Access ()

let execute_PREF (base, op, imm) = return ()

let execute_SYNC () = MEM_sync ()

let execute_MFC0 (rt, rd, sel, double) =
  checkCP0Access () >>
  match (rd,sel) with
  | (Vector [B0;B0;B0;B0;B0] _ _, Vector [B0;B0;B0] _ _) ->
     read_reg TLBIndex >>= fun w__0 ->
     let idx = set_vector_start 30 (extz ((31:ii),w__0)) in
     read_reg TLBProbe >>= fun w__1 ->
     return (set_vector_start 63
       ((set_vector_start_to_length
          (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 31 false)) ^^
        (set_vector_start_to_length
          ((set_vector_start_to_length (Vector [most_significant w__1] 0 false)) ^^
           (set_vector_start_to_length idx)))))
  | (Vector [B0;B0;B0;B0;B1] _ _, Vector [B0;B0;B0] _ _) ->
     read_reg TLBRandom >>= fun w__2 ->
     return (set_vector_start 63 (extz ((64:ii),w__2)))
  | (Vector [B0;B0;B0;B1;B0] _ _, Vector [B0;B0;B0] _ _) -> read_reg TLBEntryLo0
  | (Vector [B0;B0;B0;B1;B1] _ _, Vector [B0;B0;B0] _ _) -> read_reg TLBEntryLo1
  | (Vector [B0;B0;B1;B0;B0] _ _, Vector [B0;B0;B0] _ _) -> read_reg TLBContext
  | (Vector [B0;B0;B1;B0;B1] _ _, Vector [B0;B0;B0] _ _) ->
     read_reg TLBPageMask >>= fun w__6 ->
     return (set_vector_start 63
       (extz
          ((64:ii),
           reset_vector_start (set_vector_start_to_length
             (w__6 ^^
              (set_vector_start_to_length (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 11 false)))))))
  | (Vector [B0;B0;B1;B1;B0] _ _, Vector [B0;B0;B0] _ _) ->
     read_reg TLBWired >>= fun w__7 ->
     return (set_vector_start 63 (extz ((64:ii),w__7)))
  | (Vector [B0;B0;B1;B1;B1] _ _, Vector [B0;B0;B0] _ _) ->
     read_reg CP0HWREna >>= fun w__8 ->
     return (set_vector_start 63 (extz ((64:ii),w__8)))
  | (Vector [B0;B1;B0;B0;B0] _ _, Vector [B0;B0;B0] _ _) -> read_reg CP0BadVAddr
  | (Vector [B0;B1;B0;B0;B0] _ _, Vector [B0;B0;B1] _ _) -> return (to_vec_dec ((64:ii),(0:ii)))
  | (Vector [B0;B1;B0;B0;B1] _ _, Vector [B0;B0;B0] _ _) ->
     read_reg CP0Count >>= fun w__10 ->
     return (set_vector_start 63 (extz ((64:ii),w__10)))
  | (Vector [B0;B1;B0;B1;B0] _ _, Vector [B0;B0;B0] _ _) -> read_reg TLBEntryHi
  | (Vector [B0;B1;B0;B1;B1] _ _, Vector [B0;B0;B0] _ _) ->
     read_reg CP0Compare >>= fun w__12 ->
     return (set_vector_start 63 (extz ((64:ii),w__12)))
  | (Vector [B0;B1;B1;B0;B0] _ _, Vector [B0;B0;B0] _ _) ->
     read_reg CP0Status >>= fun w__13 ->
     return (set_vector_start 63 (extz ((64:ii),w__13)))
  | (Vector [B0;B1;B1;B0;B1] _ _, Vector [B0;B0;B0] _ _) ->
     read_reg CP0Cause >>= fun w__14 ->
     return (set_vector_start 63 (extz ((64:ii),w__14)))
  | (Vector [B0;B1;B1;B1;B0] _ _, Vector [B0;B0;B0] _ _) -> read_reg CP0EPC
  | (Vector [B0;B1;B1;B1;B1] _ _, Vector [B0;B0;B0] _ _) ->
     return (set_vector_start 63
       (extz
          ((64:ii),
           reset_vector_start (set_vector_start_to_length
             (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                      B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 31 false)))))
  | (Vector [B0;B1;B1;B1;B1] _ _, Vector [B1;B1;B0] _ _) -> return (to_vec_dec ((64:ii),(0:ii)))
  | (Vector [B0;B1;B1;B1;B1] _ _, Vector [B1;B1;B1] _ _) -> return (to_vec_dec ((64:ii),(0:ii)))
  | (Vector [B1;B0;B0;B0;B0] _ _, Vector [B0;B0;B0] _ _) ->
     return (set_vector_start 63
       (extz
          ((64:ii),
           reset_vector_start (set_vector_start_to_length
             ((set_vector_start_to_length (Vector [B1] 0 false)) ^^
              (set_vector_start_to_length
                ((set_vector_start_to_length
                   (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 14 false)) ^^
                 (set_vector_start_to_length
                   ((set_vector_start_to_length (Vector [B1] 0 false)) ^^
                    (set_vector_start_to_length
                      ((set_vector_start_to_length (Vector [B1;B0] 1 false)) ^^
                       (set_vector_start_to_length
                         ((set_vector_start_to_length (Vector [B0;B0;B0] 2 false)) ^^
                          (set_vector_start_to_length
                            ((set_vector_start_to_length (Vector [B0;B0;B1] 2 false)) ^^
                             (set_vector_start_to_length
                               ((set_vector_start_to_length (Vector [B0;B0;B0;B0] 3 false)) ^^
                                (set_vector_start_to_length (Vector [B0;B0;B0] 2 false)))))))))))))))))))
  | (Vector [B1;B0;B0;B0;B0] _ _, Vector [B0;B0;B1] _ _) ->
     return (set_vector_start 63
       (extz
          ((64:ii),
           reset_vector_start (set_vector_start_to_length
             ((set_vector_start_to_length (Vector [B1] 0 false)) ^^
              (set_vector_start_to_length
                (TLBIndexMax ^^
                 (set_vector_start_to_length
                   ((set_vector_start_to_length (Vector [B0;B0;B0] 2 false)) ^^
                    (set_vector_start_to_length
                      ((set_vector_start_to_length (Vector [B0;B0;B0] 2 false)) ^^
                       (set_vector_start_to_length
                         ((set_vector_start_to_length (Vector [B0;B0;B0] 2 false)) ^^
                          (set_vector_start_to_length
                            ((set_vector_start_to_length (Vector [B0;B0;B0] 2 false)) ^^
                             (set_vector_start_to_length
                               ((set_vector_start_to_length (Vector [B0;B0;B0] 2 false)) ^^
                                (set_vector_start_to_length
                                  ((set_vector_start_to_length (Vector [B0;B0;B0] 2 false)) ^^
                                   (set_vector_start_to_length
                                     ((set_vector_start_to_length (Vector [have_cp2] 0 false)) ^^
                                      (set_vector_start_to_length
                                        ((set_vector_start_to_length (Vector [B0] 0 false)) ^^
                                         (set_vector_start_to_length
                                           ((set_vector_start_to_length (Vector [B0] 0 false)) ^^
                                            (set_vector_start_to_length
                                              ((set_vector_start_to_length (Vector [B0] 0 false)) ^^
                                               (set_vector_start_to_length
                                                 ((set_vector_start_to_length (Vector [B0] 0 false)) ^^
                                                  (set_vector_start_to_length
                                                    ((set_vector_start_to_length
                                                       (Vector [B0] 0 false)) ^^
                                                     (set_vector_start_to_length
                                                       (Vector [B0] 0 false)))))))))))))))))))))))))))))))))
  | (Vector [B1;B0;B0;B0;B0] _ _, Vector [B0;B1;B0] _ _) ->
     return (set_vector_start 63
       (extz
          ((64:ii),
           reset_vector_start (set_vector_start_to_length
             ((set_vector_start_to_length (Vector [B1] 0 false)) ^^
              (set_vector_start_to_length
                ((set_vector_start_to_length (Vector [B0;B0;B0] 2 false)) ^^
                 (set_vector_start_to_length
                   ((set_vector_start_to_length (Vector [B0;B0;B0;B0] 3 false)) ^^
                    (set_vector_start_to_length
                      ((set_vector_start_to_length (Vector [B0;B0;B0;B0] 3 false)) ^^
                       (set_vector_start_to_length
                         ((set_vector_start_to_length (Vector [B0;B0;B0;B0] 3 false)) ^^
                          (set_vector_start_to_length
                            ((set_vector_start_to_length (Vector [B0;B0;B0;B0] 3 false)) ^^
                             (set_vector_start_to_length
                               ((set_vector_start_to_length (Vector [B0;B0;B0;B0] 3 false)) ^^
                                (set_vector_start_to_length
                                  ((set_vector_start_to_length (Vector [B0;B0;B0;B0] 3 false)) ^^
                                   (set_vector_start_to_length (Vector [B0;B0;B0;B0] 3 false)))))))))))))))))))))
  | (Vector [B1;B0;B0;B0;B0] _ _, Vector [B0;B1;B1] _ _) ->
     return (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0] 63 false)
  | (Vector [B1;B0;B0;B0;B0] _ _, Vector [B1;B0;B1] _ _) ->
     return (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0] 63 false)
  | (Vector [B1;B0;B0;B0;B1] _ _, Vector [B0;B0;B0] _ _) -> read_reg CP0LLAddr
  | (Vector [B1;B0;B0;B1;B0] _ _, Vector [B0;B0;B0] _ _) -> return (to_vec_dec ((64:ii),(0:ii)))
  | (Vector [B1;B0;B0;B1;B1] _ _, Vector [B0;B0;B0] _ _) -> return (to_vec_dec ((64:ii),(0:ii)))
  | (Vector [B1;B0;B1;B0;B0] _ _, Vector [B0;B0;B0] _ _) -> read_reg TLBXContext
  | (Vector [B1;B1;B1;B1;B0] _ _, Vector [B0;B0;B0] _ _) -> read_reg CP0ErrorEPC
  | _ -> SignalException ResI
  end >>= fun result ->
  wGPR
    (rt,
     reset_vector_start (if bitU_to_bool double
                         then result
                         else
                           set_vector_start 63
                             (exts
                                ((64:ii),
                                 reset_vector_start (set_vector_start_to_length
                                   (slice result (31:ii) (0:ii)))))))

let execute_HCF () = return ()

let execute_MTC0 (rt, rd, sel, double) =
  checkCP0Access () >>
  rGPR rt >>= fun reg_val ->
  match (rd,sel) with
  | (Vector [B0;B0;B0;B0;B0] _ _, Vector [B0;B0;B0] _ _) ->
     write_reg TLBIndex (mask ((6:ii),reset_vector_start (set_vector_start_to_length reg_val)))
  | (Vector [B0;B0;B0;B0;B1] _ _, Vector [B0;B0;B0] _ _) -> return ()
  | (Vector [B0;B0;B0;B1;B0] _ _, Vector [B0;B0;B0] _ _) -> write_reg TLBEntryLo0 reg_val
  | (Vector [B0;B0;B0;B1;B1] _ _, Vector [B0;B0;B0] _ _) -> write_reg TLBEntryLo1 reg_val
  | (Vector [B0;B0;B1;B0;B0] _ _, Vector [B0;B0;B0] _ _) ->
     write_reg_field TLBContext "PTEBase" (slice reg_val (63:ii) (23:ii))
  | (Vector [B0;B0;B1;B0;B0] _ _, Vector [B0;B1;B0] _ _) -> write_reg CP0UserLocal reg_val
  | (Vector [B0;B0;B1;B0;B1] _ _, Vector [B0;B0;B0] _ _) ->
     write_reg TLBPageMask (set_vector_start 15 (slice reg_val (28:ii) (13:ii)))
  | (Vector [B0;B0;B1;B1;B0] _ _, Vector [B0;B0;B0] _ _) ->
     write_reg TLBWired (mask ((6:ii),reset_vector_start (set_vector_start_to_length reg_val))) >>
     write_reg TLBRandom TLBIndexMax
  | (Vector [B0;B0;B1;B1;B1] _ _, Vector [B0;B0;B0] _ _) ->
     write_reg
       CP0HWREna
       (set_vector_start 31
         ((set_vector_start_to_length (slice reg_val (31:ii) (29:ii))) ^^
          (set_vector_start_to_length
            ((set_vector_start_to_length
               (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 24 false)) ^^
             (set_vector_start_to_length (slice reg_val (3:ii) (0:ii)))))))
  | (Vector [B0;B1;B0;B0;B0] _ _, Vector [B0;B0;B0] _ _) -> return ()
  | (Vector [B0;B1;B0;B0;B1] _ _, Vector [B0;B0;B0] _ _) ->
     write_reg CP0Count (slice reg_val (31:ii) (0:ii))
  | (Vector [B0;B1;B0;B1;B0] _ _, Vector [B0;B0;B0] _ _) ->
     write_reg_field TLBEntryHi "R" (slice reg_val (63:ii) (62:ii)) >>
     write_reg_field TLBEntryHi "VPN2" (slice reg_val (39:ii) (13:ii)) >>
     write_reg_field TLBEntryHi "ASID" (slice reg_val (7:ii) (0:ii))
  | (Vector [B0;B1;B0;B1;B1] _ _, Vector [B0;B0;B0] _ _) ->
     write_reg CP0Compare (slice reg_val (31:ii) (0:ii)) >>
     write_reg_bit CP0Cause (15:ii) B0
  | (Vector [B0;B1;B1;B0;B0] _ _, Vector [B0;B0;B0] _ _) ->
     write_reg_field CP0Status "CU" (slice reg_val (31:ii) (28:ii)) >>
     write_reg_bitfield CP0Status "BEV" (access reg_val (22:ii)) >>
     write_reg_field CP0Status "IM" (slice reg_val (15:ii) (8:ii)) >>
     write_reg_bitfield CP0Status "KX" (access reg_val (7:ii)) >>
     write_reg_bitfield CP0Status "SX" (access reg_val (6:ii)) >>
     write_reg_bitfield CP0Status "UX" (access reg_val (5:ii)) >>
     write_reg_field CP0Status "KSU" (slice reg_val (4:ii) (3:ii)) >>
     write_reg_bitfield CP0Status "ERL" (access reg_val (2:ii)) >>
     write_reg_bitfield CP0Status "EXL" (access reg_val (1:ii)) >>
     write_reg_bitfield CP0Status "IE" (access reg_val (0:ii))
  | (Vector [B0;B1;B1;B0;B1] _ _, Vector [B0;B0;B0] _ _) ->
     write_reg_bitfield CP0Cause "IV" (access reg_val (23:ii)) >>
     read_reg_field CP0Cause "IP" >>= fun w__0 ->
     let ip = set_vector_start 7 w__0 in
     write_reg_field
       CP0Cause "IP"
       (set_vector_start 15
         ((set_vector_start_to_length (slice ip (7:ii) (2:ii))) ^^
          (set_vector_start_to_length (slice reg_val (9:ii) (8:ii)))))
  | (Vector [B0;B1;B1;B1;B0] _ _, Vector [B0;B0;B0] _ _) -> write_reg CP0EPC reg_val
  | (Vector [B1;B0;B0;B0;B0] _ _, Vector [B0;B0;B0] _ _) -> return ()
  | (Vector [B1;B0;B1;B0;B0] _ _, Vector [B0;B0;B0] _ _) ->
     write_reg_field TLBXContext "PTEBase" (slice reg_val (63:ii) (33:ii))
  | (Vector [B1;B1;B1;B1;B0] _ _, Vector [B0;B0;B0] _ _) -> write_reg CP0ErrorEPC reg_val
  | _ -> SignalException ResI
  end

let execute_TLBWI () =
  checkCP0Access () >>
  read_reg TLBIndex >>= fun w__0 ->
  TLBWriteEntry w__0

let execute_TLBWR () =
  checkCP0Access () >>
  read_reg TLBRandom >>= fun w__0 ->
  TLBWriteEntry w__0

let execute_TLBR () =
  checkCP0Access () >>
  read_reg TLBIndex >>= fun w__0 ->
  let entry = access TLBEntries (unsigned w__0) in
  read_reg_field entry "pagemask" >>= fun w__1 ->
  write_reg TLBPageMask (set_vector_start 15 w__1) >>
  read_reg_field entry "r" >>= fun w__2 ->
  write_reg_field TLBEntryHi "R" (set_vector_start 63 w__2) >>
  read_reg_field entry "vpn2" >>= fun w__3 ->
  write_reg_field TLBEntryHi "VPN2" (set_vector_start 39 w__3) >>
  read_reg_field entry "asid" >>= fun w__4 ->
  write_reg_field TLBEntryHi "ASID" (set_vector_start 7 w__4) >>
  read_reg_bitfield entry "caps0" >>= fun w__5 ->
  write_reg_bitfield TLBEntryLo0 "CapS" w__5 >>
  read_reg_bitfield entry "capl0" >>= fun w__6 ->
  write_reg_bitfield TLBEntryLo0 "CapL" w__6 >>
  read_reg_field entry "pfn0" >>= fun w__7 ->
  write_reg_field TLBEntryLo0 "PFN" (set_vector_start 29 w__7) >>
  read_reg_field entry "c0" >>= fun w__8 ->
  write_reg_field TLBEntryLo0 "C" (set_vector_start 5 w__8) >>
  read_reg_bitfield entry "d0" >>= fun w__9 ->
  write_reg_bitfield TLBEntryLo0 "D" w__9 >>
  read_reg_bitfield entry "v0" >>= fun w__10 ->
  write_reg_bitfield TLBEntryLo0 "V" w__10 >>
  read_reg_bitfield entry "g" >>= fun w__11 ->
  write_reg_bitfield TLBEntryLo0 "G" w__11 >>
  read_reg_bitfield entry "caps1" >>= fun w__12 ->
  write_reg_bitfield TLBEntryLo1 "CapS" w__12 >>
  read_reg_bitfield entry "capl1" >>= fun w__13 ->
  write_reg_bitfield TLBEntryLo1 "CapL" w__13 >>
  read_reg_field entry "pfn1" >>= fun w__14 ->
  write_reg_field TLBEntryLo1 "PFN" (set_vector_start 29 w__14) >>
  read_reg_field entry "c1" >>= fun w__15 ->
  write_reg_field TLBEntryLo1 "C" (set_vector_start 5 w__15) >>
  read_reg_bitfield entry "d1" >>= fun w__16 ->
  write_reg_bitfield TLBEntryLo1 "D" w__16 >>
  read_reg_bitfield entry "v1" >>= fun w__17 ->
  write_reg_bitfield TLBEntryLo1 "V" w__17 >>
  read_reg_bitfield entry "g" >>= fun w__18 ->
  write_reg_bitfield TLBEntryLo1 "G" w__18

let execute_TLBP () =
  checkCP0Access () >>
  read_reg TLBEntryHi >>= fun w__0 ->
  let result = tlbSearch w__0 in
  match result with
  | Just (idx) ->
     write_reg TLBProbe (Vector [B0] 0 false) >>
     write_reg TLBIndex idx
  | Nothing ->
     write_reg TLBProbe (Vector [B1] 0 false) >>
     write_reg TLBIndex (to_vec_dec ((6:ii),(0:ii)))
  end

let execute_RDHWR (rt, rd) =
  getAccessLevel () >>= fun accessLevel ->
  read_reg_field CP0Status "CU" >>= fun w__0 ->
  read_reg_bit CP0HWREna (unsigned rd) >>= fun w__1 ->
  (if bitU_to_bool
        ((neq (accessLevel, Kernel)) &.
           ((~(access (set_vector_start_to_length w__0) (0:ii))) &. (~w__1)))
   then SignalException ResI
   else return ()) >>
  match rd with
  | Vector [B0;B0;B0;B0;B0] _ _ ->
     return (set_vector_start 63
       (extz ((64:ii),reset_vector_start (set_vector_start_to_length (Vector [B0] 0 false)))))
  | Vector [B0;B0;B0;B0;B1] _ _ ->
     return (set_vector_start 63
       (extz ((64:ii),reset_vector_start (set_vector_start_to_length (Vector [B0] 0 false)))))
  | Vector [B0;B0;B0;B1;B0] _ _ ->
     read_reg CP0Count >>= fun w__2 ->
     return (set_vector_start 63 (extz ((64:ii),w__2)))
  | Vector [B0;B0;B0;B1;B1] _ _ ->
     return (set_vector_start 63
       (extz ((64:ii),reset_vector_start (set_vector_start_to_length (Vector [B1] 0 false)))))
  | Vector [B1;B1;B1;B0;B1] _ _ -> read_reg CP0UserLocal
  | _ -> SignalException ResI
  end >>= fun temp ->
  wGPR (rt,reset_vector_start temp)

let execute_ERET () =
  checkCP0Access () >>
  let _ = ERETHook () in
  write_reg CP0LLBit (Vector [B0] 0 false) >>
  read_reg_bitfield CP0Status "ERL" >>= fun w__0 ->
  if bitU_to_bool (eq_bit (w__0, B1))
  then
    read_reg CP0ErrorEPC >>= fun w__1 ->
    write_reg nextPC w__1 >>
    write_reg_bitfield CP0Status "ERL" B0
  else
    read_reg CP0EPC >>= fun w__2 ->
    write_reg nextPC w__2 >>
    write_reg_bitfield CP0Status "EXL" B0

let execute = function
  
  | DADDIU (rs,rt,imm) -> execute_DADDIU (rs,rt,imm)
  | DADDU (rs,rt,rd) -> execute_DADDU (rs,rt,rd)
  | DADDI (rs,rt,imm) -> execute_DADDI (rs,rt,imm)
  | DADD (rs,rt,rd) -> execute_DADD (rs,rt,rd)
  | ADD (rs,rt,rd) -> execute_ADD (rs,rt,rd)
  | ADDI (rs,rt,imm) -> execute_ADDI (rs,rt,imm)
  | ADDU (rs,rt,rd) -> execute_ADDU (rs,rt,rd)
  | ADDIU (rs,rt,imm) -> execute_ADDIU (rs,rt,imm)
  | DSUBU (rs,rt,rd) -> execute_DSUBU (rs,rt,rd)
  | DSUB (rs,rt,rd) -> execute_DSUB (rs,rt,rd)
  | SUB (rs,rt,rd) -> execute_SUB (rs,rt,rd)
  | SUBU (rs,rt,rd) -> execute_SUBU (rs,rt,rd)
  | AND (rs,rt,rd) -> execute_AND (rs,rt,rd)
  | ANDI (rs,rt,imm) -> execute_ANDI (rs,rt,imm)
  | OR (rs,rt,rd) -> execute_OR (rs,rt,rd)
  | ORI (rs,rt,imm) -> execute_ORI (rs,rt,imm)
  | NOR (rs,rt,rd) -> execute_NOR (rs,rt,rd)
  | XOR (rs,rt,rd) -> execute_XOR (rs,rt,rd)
  | XORI (rs,rt,imm) -> execute_XORI (rs,rt,imm)
  | LUI (rt,imm) -> execute_LUI (rt,imm)
  | DSLL (rt,rd,sa) -> execute_DSLL (rt,rd,sa)
  | DSLL32 (rt,rd,sa) -> execute_DSLL32 (rt,rd,sa)
  | DSLLV (rs,rt,rd) -> execute_DSLLV (rs,rt,rd)
  | DSRA (rt,rd,sa) -> execute_DSRA (rt,rd,sa)
  | DSRA32 (rt,rd,sa) -> execute_DSRA32 (rt,rd,sa)
  | DSRAV (rs,rt,rd) -> execute_DSRAV (rs,rt,rd)
  | DSRL (rt,rd,sa) -> execute_DSRL (rt,rd,sa)
  | DSRL32 (rt,rd,sa) -> execute_DSRL32 (rt,rd,sa)
  | DSRLV (rs,rt,rd) -> execute_DSRLV (rs,rt,rd)
  | SLL (rt,rd,sa) -> execute_SLL (rt,rd,sa)
  | SLLV (rs,rt,rd) -> execute_SLLV (rs,rt,rd)
  | SRA (rt,rd,sa) -> execute_SRA (rt,rd,sa)
  | SRAV (rs,rt,rd) -> execute_SRAV (rs,rt,rd)
  | SRL (rt,rd,sa) -> execute_SRL (rt,rd,sa)
  | SRLV (rs,rt,rd) -> execute_SRLV (rs,rt,rd)
  | SLT (rs,rt,rd) -> execute_SLT (rs,rt,rd)
  | SLTI (rs,rt,imm) -> execute_SLTI (rs,rt,imm)
  | SLTU (rs,rt,rd) -> execute_SLTU (rs,rt,rd)
  | SLTIU (rs,rt,imm) -> execute_SLTIU (rs,rt,imm)
  | MOVN (rs,rt,rd) -> execute_MOVN (rs,rt,rd)
  | MOVZ (rs,rt,rd) -> execute_MOVZ (rs,rt,rd)
  | MFHI (rd) -> execute_MFHI (rd)
  | MFLO (rd) -> execute_MFLO (rd)
  | MTHI (rs) -> execute_MTHI (rs)
  | MTLO (rs) -> execute_MTLO (rs)
  | MUL (rs,rt,rd) -> execute_MUL (rs,rt,rd)
  | MULT (rs,rt) -> execute_MULT (rs,rt)
  | MULTU (rs,rt) -> execute_MULTU (rs,rt)
  | DMULT (rs,rt) -> execute_DMULT (rs,rt)
  | DMULTU (rs,rt) -> execute_DMULTU (rs,rt)
  | MADD (rs,rt) -> execute_MADD (rs,rt)
  | MADDU (rs,rt) -> execute_MADDU (rs,rt)
  | MSUB (rs,rt) -> execute_MSUB (rs,rt)
  | MSUBU (rs,rt) -> execute_MSUBU (rs,rt)
  | DIV (rs,rt) -> execute_DIV (rs,rt)
  | DIVU (rs,rt) -> execute_DIVU (rs,rt)
  | DDIV (rs,rt) -> execute_DDIV (rs,rt)
  | DDIVU (rs,rt) -> execute_DDIVU (rs,rt)
  | J (offset) -> execute_J (offset)
  | JAL (offset) -> execute_JAL (offset)
  | JR (rs) -> execute_JR (rs)
  | JALR (rs,rd) -> execute_JALR (rs,rd)
  | BEQ (rs,rd,imm,ne,likely) -> execute_BEQ (rs,rd,imm,ne,likely)
  | BCMPZ (rs,imm,cmp,link,likely) -> execute_BCMPZ (rs,imm,cmp,link,likely)
  | SYSCALL_THREAD_START -> execute_SYSCALL_THREAD_START ()
  | ImplementationDefinedStopFetching -> execute_ImplementationDefinedStopFetching ()
  | SYSCALL -> execute_SYSCALL ()
  | BREAK -> execute_BREAK ()
  | WAIT -> execute_WAIT ()
  | TRAPREG (rs,rt,cmp) -> execute_TRAPREG (rs,rt,cmp)
  | TRAPIMM (rs,imm,cmp) -> execute_TRAPIMM (rs,imm,cmp)
  | Load (width,signed,linked,base,rt,offset) -> execute_Load (width,signed,linked,base,rt,offset)
  | Store (width,conditional,base,rt,offset) -> execute_Store (width,conditional,base,rt,offset)
  | LWL (base,rt,offset) -> execute_LWL (base,rt,offset)
  | LWR (base,rt,offset) -> execute_LWR (base,rt,offset)
  | SWL (base,rt,offset) -> execute_SWL (base,rt,offset)
  | SWR (base,rt,offset) -> execute_SWR (base,rt,offset)
  | LDL (base,rt,offset) -> execute_LDL (base,rt,offset)
  | LDR (base,rt,offset) -> execute_LDR (base,rt,offset)
  | SDL (base,rt,offset) -> execute_SDL (base,rt,offset)
  | SDR (base,rt,offset) -> execute_SDR (base,rt,offset)
  | CACHE (base,op,imm) -> execute_CACHE (base,op,imm)
  | PREF (base,op,imm) -> execute_PREF (base,op,imm)
  | SYNC -> execute_SYNC ()
  | MFC0 (rt,rd,sel,double) -> execute_MFC0 (rt,rd,sel,double)
  | HCF -> execute_HCF ()
  | MTC0 (rt,rd,sel,double) -> execute_MTC0 (rt,rd,sel,double)
  | TLBWI -> execute_TLBWI ()
  | TLBWR -> execute_TLBWR ()
  | TLBR -> execute_TLBR ()
  | TLBP -> execute_TLBP ()
  | RDHWR (rt,rd) -> execute_RDHWR (rt,rd)
  | ERET -> execute_ERET ()
  end

