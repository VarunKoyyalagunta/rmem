(*Generated by Sail from x86.sail.*)
open import Pervasives_extra
open import Sail_impl_base
open import State
open import Sail_values
open import X86_embed_types
open import X86_extras_embed_sequential
let ASR8 (v, shift) =
  let v2 = set_vector_start 15 (exts ((16:ii),reset_vector_start (set_vector_start_to_length v))) in
  set_vector_start 7
    (mask
       ((8:ii),
        reset_vector_start (set_vector_start_to_length
          (bitwise_rightshift (set_vector_start_to_length v2, shift)))))

let ASR16 (v, shift) =
  let v2 = set_vector_start 31 (exts ((32:ii),reset_vector_start (set_vector_start_to_length v))) in
  set_vector_start 15
    (mask
       ((16:ii),
        reset_vector_start (set_vector_start_to_length
          (bitwise_rightshift (set_vector_start_to_length v2, shift)))))

let ASR32 (v, shift) =
  let v2 = set_vector_start 63 (exts ((64:ii),reset_vector_start (set_vector_start_to_length v))) in
  set_vector_start 31
    (mask
       ((32:ii),
        reset_vector_start (set_vector_start_to_length
          (bitwise_rightshift (set_vector_start_to_length v2, shift)))))

let ASR64 (v, shift) =
  let v2 = set_vector_start 127 (exts ((128:ii),reset_vector_start (set_vector_start_to_length v))) in
  set_vector_start 63
    (mask
       ((64:ii),
        reset_vector_start (set_vector_start_to_length
          (bitwise_rightshift (set_vector_start_to_length v2, shift)))))

let ROR8 (v, shift) =
  let v2 = (set_vector_start_to_length v) ^^ (set_vector_start_to_length v) in
  set_vector_start 7
    (mask
       ((8:ii),
        reset_vector_start (set_vector_start_to_length
          (bitwise_rightshift (set_vector_start_to_length v2, shift)))))

let ROR16 (v, shift) =
  let v2 = (set_vector_start_to_length v) ^^ (set_vector_start_to_length v) in
  set_vector_start 15
    (mask
       ((16:ii),
        reset_vector_start (set_vector_start_to_length
          (bitwise_rightshift (set_vector_start_to_length v2, shift)))))

let ROR32 (v, shift) =
  let v2 = (set_vector_start_to_length v) ^^ (set_vector_start_to_length v) in
  set_vector_start 31
    (mask
       ((32:ii),
        reset_vector_start (set_vector_start_to_length
          (bitwise_rightshift (set_vector_start_to_length v2, shift)))))

let ROR64 (v, shift) =
  let v2 = (set_vector_start_to_length v) ^^ (set_vector_start_to_length v) in
  set_vector_start 63
    (mask
       ((64:ii),
        reset_vector_start (set_vector_start_to_length
          (bitwise_rightshift (set_vector_start_to_length v2, shift)))))

let ROL8 (v, shift) =
  let v2 = (set_vector_start_to_length v) ^^ (set_vector_start_to_length v) in
  set_vector_start 7
    (mask
       ((8:ii),
        reset_vector_start (set_vector_start_to_length
          (bitwise_leftshift (set_vector_start_to_length v2, shift)))))

let ROL16 (v, shift) =
  let v2 = (set_vector_start_to_length v) ^^ (set_vector_start_to_length v) in
  set_vector_start 15
    (mask
       ((16:ii),
        reset_vector_start (set_vector_start_to_length
          (bitwise_leftshift (set_vector_start_to_length v2, shift)))))

let ROL32 (v, shift) =
  let v2 = (set_vector_start_to_length v) ^^ (set_vector_start_to_length v) in
  set_vector_start 31
    (mask
       ((32:ii),
        reset_vector_start (set_vector_start_to_length
          (bitwise_leftshift (set_vector_start_to_length v2, shift)))))

let ROL64 (v, shift) =
  let v2 = (set_vector_start_to_length v) ^^ (set_vector_start_to_length v) in
  set_vector_start 63
    (mask
       ((64:ii),
        reset_vector_start (set_vector_start_to_length
          (bitwise_leftshift (set_vector_start_to_length v2, shift)))))

let negative_to_zero x = if bitU_to_bool (lt (x, (0:ii))) then (0:ii) else x

let GPRstr =
  Vector ["RAX";"RCX";"RDX";"RBX";"RSP";"RBP";"RSI";"RDI";"R8";"R9";"R10";"R11";"R12";"R13";"R14";"R15"] 0 true

let rMEMl (locked, addr, size) =
  if bitU_to_bool locked
  then
    rMEM_locked (addr,size) >>= fun w__0 ->
    return (set_vector_start_to_length w__0)
  else
    rMEM (addr,size) >>= fun w__1 ->
    return (set_vector_start_to_length w__1)

let wMEM (locked, addr, len, data) =
  (if bitU_to_bool locked
   then MEMea_locked (addr,len)
   else MEMea (addr,len)) >>
  MEMval (addr,len,reset_vector_start (set_vector_start_to_length data))

let byte_parity b =
  let acc = (0:ii) in
  let acc =
    (foreach_inc ((0:ii),(7:ii),(1:ii)) acc
      (fun i acc -> acc + (match (access b i) with | B0 -> (0:ii) | B1 -> (1:ii) end))) in
  eq_range (modulo acc (2:ii), (0:ii))

let sub4 r = negative_to_zero (r - (4:ii))

let pop_aux () =
  read_reg RSP >>= fun w__0 ->
  rMEM (w__0,(8:ii)) >>= fun top ->
  read_reg RSP >>= fun w__1 ->
  write_reg RSP (add_VIV w__1 (8:ii)) >>
  return top

let drop i =
  if bitU_to_bool (neq_vec_range (set_vector_start_to_length (slice i (7:ii) (0:ii)), (0:ii)))
  then return ()
  else
    read_reg RSP >>= fun w__0 ->
    write_reg RSP (add_VVV w__0 i)

let all_flags_but_cf_of = [RFull "ZF";RFull "SF";RFull "PF";RFull "AF"]

let write_PF w =
  write_reg PF (Vector [byte_parity (reset_vector_start (slice w (7:ii) (0:ii)))] 0 false)

let mask_shift (sz, w) =
  if bitU_to_bool (eq (sz, Sz64))
  then unsigned (reset_vector_start (slice w (5:ii) (0:ii)))
  else unsigned (reset_vector_start (slice w (4:ii) (0:ii)))

let push_aux w =
  read_reg RSP >>= fun w__0 ->
  write_reg RSP (minus_VIV w__0 (8:ii)) >>
  read_reg RSP >>= fun w__1 ->
  wMEM (B0,w__1,(8:ii),w)

let size_to_int s =
  match s with | Sz8 (_) -> (8:ii) | Sz16 -> (16:ii) | Sz32 -> (32:ii) | Sz64 -> (64:ii) end

let size_width sz =
  match sz with | Sz8 (_) -> (8:ii) | Sz16 -> (16:ii) | Sz32 -> (32:ii) | Sz64 -> (64:ii) end

let size_width_sub1 sz =
  match sz with | Sz8 (_) -> (7:ii) | Sz16 -> (15:ii) | Sz32 -> (31:ii) | Sz64 -> (63:ii) end

let regfp_idx idx =
  match idx with | Nothing -> [] | Just (scale,idx) -> [RFull (access GPRstr idx)] end

let restrict_size (sz, imm) =
  match sz with
  | Sz8 (_) ->
     bitwise_and
       (imm,
       set_vector_start_to_length
         (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1;B1;B1;B1;
                  B1] 63 false))
  | Sz16 ->
     bitwise_and
       (imm,
       set_vector_start_to_length
         (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                  B1] 63 false))
  | Sz32 ->
     bitwise_and
       (imm,
       set_vector_start_to_length
         (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                  B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                  B1] 63 false))
  | Sz64 -> imm
  end

let erase_eflags () =
  write_reg AF (to_vec_dec_undef (1:ii)) >>
  write_reg CF (to_vec_dec_undef (1:ii)) >>
  write_reg OF (to_vec_dec_undef (1:ii)) >>
  write_reg PF (to_vec_dec_undef (1:ii)) >>
  write_reg SF (to_vec_dec_undef (1:ii)) >>
  write_reg ZF (to_vec_dec_undef (1:ii))

let sign_extension (w, size1, size2) =
  let x = w in
  match (size1,size2) with
  | (Sz8 (_), Sz16) ->
     update
       x (15:ii) (0:ii)
       (set_vector_start 15
         (exts ((16:ii),reset_vector_start (set_vector_start_to_length (slice w (7:ii) (0:ii))))))
  | (Sz8 (_), Sz32) ->
     update
       x (31:ii) (0:ii)
       (set_vector_start 31
         (exts ((32:ii),reset_vector_start (set_vector_start_to_length (slice w (7:ii) (0:ii))))))
  | (Sz8 (_), Sz64) ->
     exts ((64:ii),reset_vector_start (set_vector_start_to_length (slice w (7:ii) (0:ii))))
  | (Sz16, Sz32) ->
     update
       x (31:ii) (0:ii)
       (set_vector_start 31
         (exts ((32:ii),reset_vector_start (set_vector_start_to_length (slice w (15:ii) (0:ii))))))
  | (Sz16, Sz64) ->
     exts ((64:ii),reset_vector_start (set_vector_start_to_length (slice w (15:ii) (0:ii))))
  | (Sz32, Sz64) ->
     exts ((64:ii),reset_vector_start (set_vector_start_to_length (slice w (31:ii) (0:ii))))
  | _ -> x
  end

let write_ZF (sz, w) =
  write_reg
    ZF
    (Vector [match sz with
             | Sz8 (_) ->
                eq_vec
                  (set_vector_start_to_length (slice w (7:ii) (0:ii)),
                  set_vector_start_to_length (Vector [B0;B0;B0;B0;B0;B0;B0;B0] 7 false))
             | Sz16 ->
                eq_vec
                  (set_vector_start_to_length (slice w (15:ii) (0:ii)),
                  set_vector_start_to_length
                    (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 15 false))
             | Sz32 ->
                eq_vec
                  (set_vector_start_to_length (slice w (31:ii) (0:ii)),
                  set_vector_start_to_length
                    (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                             B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 31 false))
             | Sz64 ->
                eq_vec
                  (w,
                  set_vector_start_to_length
                    (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                             B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                             B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                             B0] 63 false))
             end] 0 false)

let regfp_base b =
  match b with
  | NoBase -> []
  | RipBase -> [RFull "RIP"]
  | RegBase (b) -> [RFull (access GPRstr b)]
  end

let rol (sz, a, b) =
  match sz with
  | Sz8 (_) ->
     extz
       ((64:ii),
        reset_vector_start (set_vector_start_to_length
          (ROL8
             (reset_vector_start (slice a (7:ii) (0:ii)),
              unsigned (reset_vector_start (slice b (2:ii) (0:ii)))))))
  | Sz16 ->
     extz
       ((64:ii),
        reset_vector_start (set_vector_start_to_length
          (ROL16
             (reset_vector_start (slice a (15:ii) (0:ii)),
              unsigned (reset_vector_start (slice b (3:ii) (0:ii)))))))
  | Sz32 ->
     extz
       ((64:ii),
        reset_vector_start (set_vector_start_to_length
          (ROL32
             (reset_vector_start (slice a (31:ii) (0:ii)),
              unsigned (reset_vector_start (slice b (4:ii) (0:ii)))))))
  | Sz64 -> ROL64 (a,unsigned (reset_vector_start (slice b (5:ii) (0:ii))))
  end

let ror (sz, a, b) =
  match sz with
  | Sz8 (_) ->
     extz
       ((64:ii),
        reset_vector_start (set_vector_start_to_length
          (ROR8
             (reset_vector_start (slice a (7:ii) (0:ii)),
              unsigned (reset_vector_start (slice b (2:ii) (0:ii)))))))
  | Sz16 ->
     extz
       ((64:ii),
        reset_vector_start (set_vector_start_to_length
          (ROR16
             (reset_vector_start (slice a (15:ii) (0:ii)),
              unsigned (reset_vector_start (slice b (3:ii) (0:ii)))))))
  | Sz32 ->
     extz
       ((64:ii),
        reset_vector_start (set_vector_start_to_length
          (ROR32
             (reset_vector_start (slice a (31:ii) (0:ii)),
              unsigned (reset_vector_start (slice b (4:ii) (0:ii)))))))
  | Sz64 -> ROR64 (a,unsigned (reset_vector_start (slice b (5:ii) (0:ii))))
  end

let sar (sz, a, b) =
  match sz with
  | Sz8 (_) ->
     extz
       ((64:ii),
        reset_vector_start (set_vector_start_to_length
          (ASR8
             (reset_vector_start (slice a (7:ii) (0:ii)),
              unsigned (reset_vector_start (slice b (2:ii) (0:ii)))))))
  | Sz16 ->
     extz
       ((64:ii),
        reset_vector_start (set_vector_start_to_length
          (ASR16
             (reset_vector_start (slice a (15:ii) (0:ii)),
              unsigned (reset_vector_start (slice b (3:ii) (0:ii)))))))
  | Sz32 ->
     extz
       ((64:ii),
        reset_vector_start (set_vector_start_to_length
          (ASR32
             (reset_vector_start (slice a (31:ii) (0:ii)),
              unsigned (reset_vector_start (slice b (4:ii) (0:ii)))))))
  | Sz64 -> ASR64 (a,unsigned (reset_vector_start (slice b (5:ii) (0:ii))))
  end

let REG = Vector [RAX;RCX;RDX;RBX;RSP;RBP;RSI;RDI;R8;R9;R10;R11;R12;R13;R14;R15] 0 true

let opc_to_binop_name opc =
  match opc with
  | Vector [B0;B0;B0;B0] _ _ -> X86_Add
  | Vector [B0;B0;B0;B1] _ _ -> X86_Or
  | Vector [B0;B0;B1;B0] _ _ -> X86_Adc
  | Vector [B0;B0;B1;B1] _ _ -> X86_Sbb
  | Vector [B0;B1;B0;B0] _ _ -> X86_And
  | Vector [B0;B1;B0;B1] _ _ -> X86_Sub
  | Vector [B0;B1;B1;B0] _ _ -> X86_Xor
  | Vector [B0;B1;B1;B1] _ _ -> X86_Cmp
  | Vector [B1;B0;B0;B0] _ _ -> X86_Rol
  | Vector [B1;B0;B0;B1] _ _ -> X86_Ror
  | Vector [B1;B0;B1;B0] _ _ -> X86_Rcl
  | Vector [B1;B0;B1;B1] _ _ -> X86_Rcr
  | Vector [B1;B1;B0;B0] _ _ -> X86_Shl
  | Vector [B1;B1;B0;B1] _ _ -> X86_Shr
  | Vector [B1;B1;B1;B0] _ _ -> X86_Test
  | Vector [B1;B1;B1;B1] _ _ -> X86_Sar
  end

let bv_to_cond v =
  match v with
  | Vector [B0;B0;B0;B0] _ _ -> X86_O
  | Vector [B0;B0;B0;B1] _ _ -> X86_NO
  | Vector [B0;B0;B1;B0] _ _ -> X86_B
  | Vector [B0;B0;B1;B1] _ _ -> X86_NB
  | Vector [B0;B1;B0;B0] _ _ -> X86_E
  | Vector [B0;B1;B0;B1] _ _ -> X86_NE
  | Vector [B0;B1;B1;B0] _ _ -> X86_NA
  | Vector [B0;B1;B1;B1] _ _ -> X86_A
  | Vector [B1;B0;B0;B0] _ _ -> X86_S
  | Vector [B1;B0;B0;B1] _ _ -> X86_NS
  | Vector [B1;B0;B1;B0] _ _ -> X86_P
  | Vector [B1;B0;B1;B1] _ _ -> X86_NP
  | Vector [B1;B1;B0;B0] _ _ -> X86_L
  | Vector [B1;B1;B0;B1] _ _ -> X86_NL
  | Vector [B1;B1;B1;B0] _ _ -> X86_NG
  | Vector [B1;B1;B1;B1] _ _ -> X86_G
  end

let regfp_cond c =
  match c with
  | X86_A -> [RFull "ZF";RFull "CF"]
  | X86_NB -> [RFull "CF"]
  | X86_B -> [RFull "CF"]
  | X86_NA -> [RFull "ZF";RFull "CF"]
  | X86_E -> [RFull "ZF"]
  | X86_G -> [RFull "OF";RFull "SF";RFull "ZF"]
  | X86_NL -> [RFull "OF";RFull "SF"]
  | X86_L -> [RFull "OF";RFull "SF"]
  | X86_NG -> [RFull "OF";RFull "SF";RFull "ZF"]
  | X86_NE -> [RFull "ZF"]
  | X86_NO -> [RFull "OF"]
  | X86_NP -> [RFull "PF"]
  | X86_NS -> [RFull "SF"]
  | X86_O -> [RFull "OF"]
  | X86_P -> [RFull "PF"]
  | X86_S -> [RFull "SF"]
  | X86_ALWAYS -> []
  end

let read_cond c =
  match c with
  | X86_A ->
     read_reg CF >>= fun w__0 ->
     read_reg ZF >>= fun w__1 ->
     return (most_significant
               (reset_vector_start (bitwise_and
                                      (set_vector_start_to_length
                                        (bitwise_not (reset_vector_start w__0)),
                                      set_vector_start_to_length
                                        (bitwise_not (reset_vector_start w__1))))))
  | X86_NB ->
     read_reg CF >>= fun w__2 ->
     return (most_significant (reset_vector_start (bitwise_not (reset_vector_start w__2))))
  | X86_B ->
     read_reg CF >>= fun w__3 ->
     return (most_significant w__3)
  | X86_NA ->
     read_reg CF >>= fun w__4 ->
     read_reg ZF >>= fun w__5 ->
     return ((most_significant w__4) |. (most_significant w__5))
  | X86_E ->
     read_reg ZF >>= fun w__6 ->
     return (most_significant w__6)
  | X86_G ->
     read_reg ZF >>= fun w__7 ->
     read_reg SF >>= fun w__8 ->
     read_reg OF >>= fun w__9 ->
     return ((most_significant (reset_vector_start (bitwise_not (reset_vector_start w__7)))) &.
               (eq_vec (w__8, w__9)))
  | X86_NL ->
     read_reg SF >>= fun w__10 ->
     read_reg OF >>= fun w__11 ->
     return (eq_vec (w__10, w__11))
  | X86_L ->
     read_reg SF >>= fun w__12 ->
     read_reg OF >>= fun w__13 ->
     return (neq_vec (w__12, w__13))
  | X86_NG ->
     read_reg ZF >>= fun w__14 ->
     read_reg SF >>= fun w__15 ->
     read_reg OF >>= fun w__16 ->
     return ((most_significant w__14) |. (neq_vec (w__15, w__16)))
  | X86_NE ->
     read_reg ZF >>= fun w__17 ->
     return (most_significant (reset_vector_start (bitwise_not (reset_vector_start w__17))))
  | X86_NO ->
     read_reg OF >>= fun w__18 ->
     return (most_significant (reset_vector_start (bitwise_not (reset_vector_start w__18))))
  | X86_NP ->
     read_reg PF >>= fun w__19 ->
     return (most_significant (reset_vector_start (bitwise_not (reset_vector_start w__19))))
  | X86_NS ->
     read_reg SF >>= fun w__20 ->
     return (most_significant (reset_vector_start (bitwise_not (reset_vector_start w__20))))
  | X86_O ->
     read_reg OF >>= fun w__21 ->
     return (most_significant w__21)
  | X86_P ->
     read_reg PF >>= fun w__22 ->
     return (most_significant w__22)
  | X86_S ->
     read_reg SF >>= fun w__23 ->
     return (most_significant w__23)
  | X86_ALWAYS -> return B1
  end

let value_width sz = pow (2:ii) (size_width sz)

let word_size_msb (sz, w) = access w (size_width_sub1 sz)

let pop_rip () =
  pop_aux () >>= fun w__0 ->
  write_reg RIP w__0

let push_rip () =
  read_reg RIP >>= fun w__0 ->
  push_aux w__0

let all_flags = [RFull "OF";RFull "CF"] ++ all_flags_but_cf_of

let ea_index index =
  match index with
  | Nothing ->
     return (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0] 63 false)
  | Just (scale,idx) ->
     let x =
       bitwise_leftshift
         (set_vector_start_to_length
           (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                    B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                    B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                    B1] 63 false),
         unsigned (reset_vector_start scale)) in
     read_reg (access REG idx) >>= fun y ->
     let z = set_vector_start 127 (mult_VVV x y) in
     return (slice z (63:ii) (0:ii))
  end

let ea_base b =
  match b with
  | NoBase ->
     return (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0] 63 false)
  | RipBase -> read_reg RIP
  | RegBase (b) -> read_reg (access REG b)
  end

let get_ea_address e =
  match e with
  | Ea_i (_,i) ->
     Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
             B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
             B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
             B0] 63 false
  | Ea_r (_,r) ->
     Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
             B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
             B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
             B0] 63 false
  | Ea_m (_,a) -> a
  end

let call_dest_from_ea e =
  match e with
  | Ea_i (_,i) ->
     read_reg RIP >>= fun w__0 ->
     return (add_VVV w__0 i)
  | Ea_r (_,r) -> read_reg (access REG r)
  | Ea_m (_,a) -> rMEM (a,(8:ii))
  end

let regfp_rm r =
  match r with
  | X86_Reg (n) -> (B0,[RFull (access GPRstr n)],[])
  | Mem (idx,b,d) -> (B1,[],(regfp_idx idx) ++ (regfp_base b))
  end

let wEA (locked, e, w) =
  match e with
  | Ea_i (_,_) -> exit ()
  | Ea_r ((Sz8 (have_rex)),r) ->
     if bitU_to_bool (have_rex |. ((lt (r, (4:ii))) |. (gt (r, (7:ii)))))
     then write_reg_range (access REG r) (7:ii) (0:ii) (slice w (7:ii) (0:ii))
     else
       write_reg_range
         (access REG (sub4 r)) (15:ii)
         (8:ii)
         (set_vector_start 15 (slice w (7:ii) (0:ii)))
  | Ea_r (Sz16,r) -> write_reg_range (access REG r) (15:ii) (0:ii) (slice w (15:ii) (0:ii))
  | Ea_r (Sz32,r) ->
     write_reg
       (access REG r)
       (extz ((64:ii),reset_vector_start (set_vector_start_to_length (slice w (31:ii) (0:ii)))))
  | Ea_r (Sz64,r) -> write_reg (access REG r) w
  | Ea_m ((Sz8 (_)),a) ->
     wMEM (locked,a,(1:ii),reset_vector_start (set_vector_start_to_length (slice w (7:ii) (0:ii))))
  | Ea_m (Sz16,a) ->
     wMEM (locked,a,(2:ii),reset_vector_start (set_vector_start_to_length (slice w (15:ii) (0:ii))))
  | Ea_m (Sz32,a) ->
     wMEM (locked,a,(4:ii),reset_vector_start (set_vector_start_to_length (slice w (31:ii) (0:ii))))
  | Ea_m (Sz64,a) -> wMEM (locked,a,(8:ii),w)
  end

let EA (locked, e) =
  match e with
  | Ea_i (sz,i) -> return (restrict_size (sz,i))
  | Ea_r ((Sz8 (have_rex)),r) ->
     if bitU_to_bool (have_rex |. ((lt (r, (4:ii))) |. (gt (r, (7:ii)))))
     then read_reg (access REG r)
     else
       read_reg (access REG (sub4 r)) >>= fun w__1 ->
       return (bitwise_and
                 (set_vector_start_to_length (bitwise_rightshift (w__1, (8:ii))),
                 set_vector_start_to_length
                   (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                            B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                            B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1;B1;B1;B1;
                            B1] 63 false)))
  | Ea_r (sz,r) ->
     read_reg (access REG r) >>= fun w__3 ->
     return (restrict_size (sz,w__3))
  | Ea_m ((Sz8 (_)),a) ->
     rMEMl (locked,a,(1:ii)) >>= fun w__4 ->
     return (extz ((64:ii),reset_vector_start (set_vector_start_to_length w__4)))
  | Ea_m (Sz16,a) ->
     rMEMl (locked,a,(2:ii)) >>= fun w__5 ->
     return (extz ((64:ii),reset_vector_start (set_vector_start_to_length w__5)))
  | Ea_m (Sz32,a) ->
     rMEMl (locked,a,(4:ii)) >>= fun w__6 ->
     return (extz ((64:ii),reset_vector_start (set_vector_start_to_length w__6)))
  | Ea_m (Sz64,a) -> rMEMl (locked,a,(8:ii))
  end

let word_signed_overflow_add (sz, a, b) =
  (eq_bit (word_size_msb (sz,a), word_size_msb (sz,b))) &.
    (neq_bit (word_size_msb (sz,reset_vector_start (add_VVV a b)), word_size_msb (sz,a)))

let word_signed_overflow_sub (sz, a, b) =
  (neq_bit (word_size_msb (sz,a), word_size_msb (sz,b))) &.
    (neq_bit (word_size_msb (sz,reset_vector_start (minus_VVV a b)), word_size_msb (sz,a)))

let write_SF (sz, w) = write_reg SF (Vector [word_size_msb (sz,w)] 0 false)

let jump_to_ea e =
  call_dest_from_ea e >>= fun w__0 ->
  write_reg RIP w__0

let regfp_binop_flags op =
  match op with
  | X86_Add -> all_flags
  | X86_Sub -> all_flags
  | X86_Cmp -> all_flags
  | X86_Test -> all_flags_but_cf_of
  | X86_And -> all_flags_but_cf_of
  | X86_Xor -> all_flags_but_cf_of
  | X86_Or -> all_flags_but_cf_of
  | X86_Rol -> all_flags
  | X86_Ror -> all_flags
  | X86_Sar -> all_flags
  | X86_Shl -> all_flags
  | X86_Shr -> all_flags
  | X86_Adc -> all_flags
  | X86_Sbb -> all_flags
  end

let write_result_erase_eflags (locked, w, e) =
  erase_eflags () >>
  wEA (locked,e,w)

let ea_rm (sz, r) =
  match r with
  | X86_Reg (n) -> return (Ea_r (sz,n))
  | Mem (idx,b,d) ->
     ea_index idx >>= fun w__0 ->
     ea_base b >>= fun w__1 ->
     return (Ea_m (sz,reset_vector_start (add_VVV w__0 (reset_vector_start (add_VVV w__1 d)))))
  end

let regfp_imm_rm i_rm =
  match i_rm with
  | Rm (v) -> match (regfp_rm v) with | (v0v', v1v', v2v') -> (v0v',v1v',v2v') end
  | Imm (v) -> (B0,[],[])
  end

let regfp_dest_src ds =
  match ds with
  | Rm_i (r_m,i) ->
     let (m, rd, ars) = match (regfp_rm r_m) with | (v0v', v1v', v2v') -> (v0v',v1v',v2v') end in
     (if bitU_to_bool m
     then IK_mem_write Write_plain
     else IK_simple,ars,rd,ars)
  | Rm_r (r_m,r) ->
     let (m, rd, ars) = match (regfp_rm r_m) with | (v3v', v4v', v5v') -> (v3v',v4v',v5v') end in
     (if bitU_to_bool m
     then IK_mem_write Write_plain
     else IK_simple,(RFull (access GPRstr r)) :: ars,rd,ars)
  | R_rm (r,r_m) ->
     let (m, rs, ars) = match (regfp_rm r_m) with | (v6v', v7v', v8v') -> (v6v',v7v',v8v') end in
     (if bitU_to_bool m
     then IK_mem_read Read_plain
     else IK_simple,rs ++ ars,[RFull (access GPRstr r)],ars)
  end

let regfp_dest_src_rmw (locked, ds) =
  let rk = if bitU_to_bool locked then Read_X86_locked else Read_plain in
  let wk = if bitU_to_bool locked then Write_X86_locked else Write_plain in
  match ds with
  | Rm_i (r_m,i) ->
     let (m, rds, ars) = match (regfp_rm r_m) with | (v0v', v1v', v2v') -> (v0v',v1v',v2v') end in
     (if bitU_to_bool m
     then IK_mem_rmw (rk,wk)
     else IK_simple,rds ++ ars,rds,ars)
  | Rm_r (r_m,r) ->
     let (m, rds, ars) = match (regfp_rm r_m) with | (v3v', v4v', v5v') -> (v3v',v4v',v5v') end in
     (if bitU_to_bool m
     then IK_mem_rmw (rk,wk)
     else IK_simple,(RFull (access GPRstr r)) :: (rds ++ ars),rds,ars)
  | R_rm (r,r_m) ->
     let rds = [RFull (access GPRstr r)] in
     let (m, rs, ars) = match (regfp_rm r_m) with | (v6v', v7v', v8v') -> (v6v',v7v',v8v') end in
     (if bitU_to_bool m
     then IK_mem_read Read_plain
     else IK_simple,rds ++ ars,rds,ars)
  end

let sub_with_borrow (sz, a, b) = (minus_VVV a b,lt_vec (a, b),word_signed_overflow_sub (sz,a,b))

let write_arith_eflags_except_CF_OF (sz, w) =
  write_reg AF (to_vec_dec_undef (1:ii)) >>
  write_PF w >>
  write_SF (sz,w) >>
  write_ZF (sz,w)

let add_with_carry_out (sz, a, b) =
  (add_VVV a b,lteq (value_width sz, (unsigned a) + (unsigned b)),word_signed_overflow_add (sz,a,b))

let pop r =
  ea_rm (Sz64,r) >>= fun w__0 ->
  pop_aux () >>= fun w__1 ->
  wEA (B0,w__0,w__1)

let ea_imm_rm i_rm =
  match i_rm with | Rm (v) -> ea_rm (Sz64,v) | Imm (v) -> return (Ea_i (Sz64,v)) end

let bit_offset_ea (sz, bo) =
  let s = size_to_int sz in
  match bo with
  | Bit_rm_imm (r_m,imm) ->
     ea_rm (sz,r_m) >>= fun base_ea ->
     return (match base_ea with
             | Ea_r (_,r) -> (Ea_r (sz,r),unsigned (reset_vector_start (minus_VIV imm s)))
             | Ea_m (_,a) -> (Ea_m (sz,a),unsigned (reset_vector_start (minus_VIV imm s)))
             end)
  | Bit_rm_r (r_m,r) ->
     ea_rm (sz,r_m) >>= fun base_ea ->
     let offset = access REG r in
     match base_ea with
     | Ea_r (_,r) ->
        read_reg offset >>= fun w__0 ->
        return (Ea_r (sz,r),unsigned (reset_vector_start (minus_VIV w__0 s)))
     | Ea_m (_,a) ->
        read_reg offset >>= fun w__1 ->
        read_reg offset >>= fun w__2 ->
        return (Ea_m (Sz64,reset_vector_start (add_VIV a (quot (unsigned w__1) (8:ii)))),unsigned
                                                                                           (reset_vector_start (minus_VIV
                                                                                                                  w__2
                                                                                                                  (64:ii))))
     end
  end

let ea_dest (sz, ds) =
  match ds with
  | Rm_i (v,_) -> ea_rm (sz,v)
  | Rm_r (v,_) -> ea_rm (sz,v)
  | R_rm (v,_) -> return (Ea_r (sz,v))
  end

let ea_src (sz, ds) =
  match ds with
  | Rm_i (_,v) -> return (Ea_i (sz,v))
  | Rm_r (_,v) -> return (Ea_r (sz,v))
  | R_rm (_,v) -> ea_rm (sz,v)
  end

let initial_analysis instr =
  let iR = [] in
  let oR = [] in
  let aR = [] in
  let ik = IK_simple in
  let Nias = [NIAFP_successor] in
  let Dia = DIAFP_none in
  match instr with
  | Binop (locked,binop,sz,ds) ->
     let flags = regfp_binop_flags binop in
     let (ik', iRs, oRs, aRs) =
       match (regfp_dest_src_rmw (locked,ds)) with
       | (v0v', v1v', v2v', v3v') -> (v0v',v1v',v2v',v3v')
       end in
     let ik = ik' in
     let iR = iRs ++ iR in
     let oR = flags ++ (oRs ++ oR) in
     let aR = aRs ++ aR in
     return (Nias,ik,iR,oR,aR)
  | Bitop (locked,bitop,sz,bitoff) ->
     let rk = if bitU_to_bool locked then Read_X86_locked else Read_plain in
     let wk = if bitU_to_bool locked then Write_X86_locked else Write_plain in
     let (ik', iRs, oRs, aRs) =
       match bitoff with
       | Bit_rm_imm (r_m,imm) ->
          let (m, rs, ars) = match (regfp_rm r_m) with | (v4v', v5v', v6v') -> (v4v',v5v',v6v') end in
          (if bitU_to_bool m
          then IK_mem_rmw (rk,wk)
          else IK_simple,rs ++ ars,rs,ars)
       | Bit_rm_r (r_m,r) ->
          let rfp = RFull (access GPRstr r) in
          let (m, rs, ars) = match (regfp_rm r_m) with | (v7v', v8v', v9v') -> (v7v',v8v',v9v') end in
          (if bitU_to_bool m
          then IK_mem_rmw (rk,wk)
          else IK_simple,rfp :: (rs ++ ars),rs,if bitU_to_bool m
          then rfp :: ars
          else ars)
       end in
     let ik = ik' in
     let iR = iRs ++ iR in
     let oR = (RFull "CF") :: (oRs ++ oR) in
     let aR = aRs ++ aR in
     return (Nias,ik,iR,oR,aR)
  | CALL (irm) ->
     let (m, rs, ars) =
       match (regfp_imm_rm irm) with | (v10v', v11v', v12v') -> (v10v',v11v',v12v') end in
     let ik =
       if bitU_to_bool m
       then IK_mem_rmw (Read_plain,Write_plain)
       else IK_mem_write Write_plain in
     let iR = (RFull "RIP") :: (RFull "RSP") :: rs in
     let oR = (RFull "RSP") :: oR in
     let aR = ars in
     match irm with
     | Rm (v) -> return (NIAFP_indirect_address)
     | Imm (v) ->
        read_reg RIP >>= fun w__0 ->
        return (NIAFP_concrete_address (reset_vector_start (set_vector_start 0 (add_VVV w__0 v))))
     end >>= fun w__1 ->
     let Nias = w__1 :: Nias in
     return (Nias,ik,iR,oR,aR)
  | CLC ->
     let oR = (RFull "CF") :: oR in
     return (Nias,ik,iR,oR,aR)
  | CMC ->
     let iR = (RFull "CF") :: iR in
     let oR = (RFull "CF") :: oR in
     return (Nias,ik,iR,oR,aR)
  | CMPXCHG (locked,sz,r_m,reg) ->
     let rk = if bitU_to_bool locked then Read_X86_locked else Read_plain in
     let wk = if bitU_to_bool locked then Write_X86_locked else Write_plain in
     let (m, rs, aRs) = match (regfp_rm r_m) with | (v13v', v14v', v15v') -> (v13v',v14v',v15v') end in
     let ik = if bitU_to_bool m then IK_mem_rmw (rk,wk) else IK_simple in
     let iR = (RFull "RAX") :: (RFull (access GPRstr reg)) :: (rs ++ aRs) in
     let oR = (RFull "RAX") :: ((regfp_binop_flags X86_Cmp) ++ rs) in
     let aR = aRs in
     return (Nias,ik,iR,oR,aR)
  | X86_DIV (sz,r_m) ->
     let (m, rs, ars) = match (regfp_rm r_m) with | (v16v', v17v', v18v') -> (v16v',v17v',v18v') end in
     let ik = if bitU_to_bool m then IK_mem_read Read_plain else IK_simple in
     let iR = (RFull "RAX") :: (RFull "RDX") :: (rs ++ ars) in
     let oR = (RFull "RAX") :: (RFull "RDX") :: (oR ++ all_flags) in
     let aR = ars in
     return (Nias,ik,iR,oR,aR)
  | HLT -> return (Nias,ik,iR,oR,aR)
  | Jcc (c,imm64) ->
     let flags = regfp_cond c in
     let ik = IK_branch in
     let iR = (RFull "RIP") :: flags in
     read_reg RIP >>= fun w__2 ->
     let Nias =
       (NIAFP_concrete_address (reset_vector_start (set_vector_start 0 (add_VVV w__2 imm64)))) ::
         Nias in
     return (Nias,ik,iR,oR,aR)
  | JMP (r_m) ->
     let (m, rs, ars) = match (regfp_rm r_m) with | (v19v', v20v', v21v') -> (v19v',v20v',v21v') end in
     let ik = if bitU_to_bool m then IK_mem_read Read_plain else IK_simple in
     let iR = (RFull "RIP") :: (rs ++ ars) in
     let aR = ars in
     let Nias = (NIAFP_indirect_address) :: Nias in
     return (Nias,ik,iR,oR,aR)
  | LEA (sz,ds) ->
     let (_, irs, ors, ars) =
       match (regfp_dest_src ds) with
       | (v22v', v23v', v24v', v25v') -> (v22v',v23v',v24v',v25v')
       end in
     let iR = irs in
     let oR = ors in
     let aR = ars in
     return (Nias,ik,iR,oR,aR)
  | LEAVE ->
     let ik = IK_mem_read Read_plain in
     let iR = (RFull "RBP") :: iR in
     let oR = (RFull "RBP") :: (RFull "RSP") :: oR in
     let aR = (RFull "RBP") :: aR in
     return (Nias,ik,iR,oR,aR)
  | LOOP (c,imm64) ->
     let flags = regfp_cond c in
     let ik = IK_branch in
     let iR = (RFull "RCX") :: flags in
     let oR = (RFull "RCX") :: oR in
     read_reg RIP >>= fun w__3 ->
     let Nias =
       (NIAFP_concrete_address (reset_vector_start (set_vector_start 0 (add_VVV w__3 imm64)))) ::
         Nias in
     return (Nias,ik,iR,oR,aR)
  | MFENCE ->
     let ik = IK_barrier (Barrier_x86_MFENCE) in
     return (Nias,ik,iR,oR,aR)
  | Monop (locked,monop,sz,r_m) ->
     let rk = if bitU_to_bool locked then Read_X86_locked else Read_plain in
     let wk = if bitU_to_bool locked then Write_X86_locked else Write_plain in
     let (m, rds, ars) =
       match (regfp_rm r_m) with | (v26v', v27v', v28v') -> (v26v',v27v',v28v') end in
     let ik = if bitU_to_bool m then IK_mem_rmw (rk,wk) else IK_simple in
     let iR = rds ++ ars in
     let oR = all_flags_but_cf_of ++ rds in
     let aR = ars in
     return (Nias,ik,iR,oR,aR)
  | MOV (c,sz,ds) ->
     let (ik', irs, ors, ars) =
       match (regfp_dest_src ds) with
       | (v29v', v30v', v31v', v32v') -> (v29v',v30v',v31v',v32v')
       end in
     let flags = regfp_cond c in
     let ik = ik' in
     let iR = irs ++ flags in
     let oR = ors in
     let aR = ars in
     return (Nias,ik,iR,oR,aR)
  | MOVSX (sz1,ds,sz2) ->
     let (ik', irs, ors, ars) =
       match (regfp_dest_src ds) with
       | (v33v', v34v', v35v', v36v') -> (v33v',v34v',v35v',v36v')
       end in
     let ik = ik' in
     let iR = irs in
     let oR = ors in
     let aR = ars in
     return (Nias,ik,iR,oR,aR)
  | MOVZX (sz1,ds,sz2) ->
     let (ik', irs, ors, ars) =
       match (regfp_dest_src ds) with
       | (v37v', v38v', v39v', v40v') -> (v37v',v38v',v39v',v40v')
       end in
     let ik = ik' in
     let iR = irs in
     let oR = ors in
     let aR = ars in
     return (Nias,ik,iR,oR,aR)
  | X86_MUL (sz,r_m) ->
     let (m, rs, ars) = match (regfp_rm r_m) with | (v41v', v42v', v43v') -> (v41v',v42v',v43v') end in
     let ik = if bitU_to_bool m then IK_mem_read Read_plain else IK_simple in
     let iR = (RFull "RAX") :: (rs ++ ars) in
     let oR = (RFull "RAX") :: (RFull "RDX") :: (oR ++ all_flags) in
     let aR = ars in
     return (Nias,ik,iR,oR,aR)
  | X86_NOP (_) -> return (Nias,ik,iR,oR,aR)
  | POP (r_m) ->
     let (m, rd, ars) = match (regfp_rm r_m) with | (v44v', v45v', v46v') -> (v44v',v45v',v46v') end in
     let ik =
       if bitU_to_bool m
       then IK_mem_rmw (Read_plain,Write_plain)
       else IK_mem_write Write_plain in
     let iR = (RFull "RSP") :: ars in
     let oR = (RFull "RSP") :: rd in
     let aR = (RFull "RSP") :: ars in
     return (Nias,ik,iR,oR,aR)
  | PUSH (irm) ->
     let (m, rs, ars) =
       match (regfp_imm_rm irm) with | (v47v', v48v', v49v') -> (v47v',v48v',v49v') end in
     let ik =
       if bitU_to_bool m
       then IK_mem_rmw (Read_plain,Write_plain)
       else IK_mem_write Write_plain in
     let iR = (RFull "RSP") :: (rs ++ ars) in
     let oR = (RFull "RSP") :: oR in
     let aR = (RFull "RSP") :: ars in
     return (Nias,ik,iR,oR,aR)
  | RET (imm64) ->
     let ik = IK_mem_read Read_plain in
     let iR = (RFull "RSP") :: iR in
     let oR = (RFull "RSP") :: oR in
     let aR = (RFull "RSP") :: aR in
     let Nias = (NIAFP_indirect_address) :: Nias in
     return (Nias,ik,iR,oR,aR)
  | SET (c,b,r_m) ->
     let flags = regfp_cond c in
     let (m, rs, ars) = match (regfp_rm r_m) with | (v50v', v51v', v52v') -> (v50v',v51v',v52v') end in
     let ik = if bitU_to_bool m then IK_mem_write Write_plain else IK_simple in
     let iR = flags ++ ars in
     let oR = rs in
     let aR = ars in
     return (Nias,ik,iR,oR,aR)
  | STC ->
     let oR = [RFull "CF"] in
     return (Nias,ik,iR,oR,aR)
  | XADD (locked,sz,r_m,reg) ->
     let rk = if bitU_to_bool locked then Read_X86_locked else Read_plain in
     let wk = if bitU_to_bool locked then Write_X86_locked else Write_plain in
     let (m, rs, ars) = match (regfp_rm r_m) with | (v53v', v54v', v55v') -> (v53v',v54v',v55v') end in
     let ik = if bitU_to_bool m then IK_mem_rmw (rk,wk) else IK_simple in
     let iR = (RFull (access GPRstr reg)) :: (rs ++ ars) in
     let oR = (RFull (access GPRstr reg)) :: (rs ++ all_flags) in
     let aR = ars in
     return (Nias,ik,iR,oR,aR)
  | XCHG (locked,sz,r_m,reg) ->
     let rk = if bitU_to_bool locked then Read_X86_locked else Read_plain in
     let wk = if bitU_to_bool locked then Write_X86_locked else Write_plain in
     let (m, rs, ars) = match (regfp_rm r_m) with | (v56v', v57v', v58v') -> (v56v',v57v',v58v') end in
     let ik = if bitU_to_bool m then IK_mem_rmw (rk,wk) else IK_simple in
     let iR = (RFull (access GPRstr reg)) :: (rs ++ ars) in
     let oR = (RFull (access GPRstr reg)) :: rs in
     let aR = ars in
     return (Nias,ik,iR,oR,aR)
  end >>= fun (Nias, ik, iR, oR, aR) ->
  return (iR,oR,aR,Nias,Dia,ik)

let write_arith_eflags (sz, w, c, x) =
  write_reg CF (Vector [c] 0 false) >>
  write_reg OF (Vector [x] 0 false) >>
  write_arith_eflags_except_CF_OF (sz,w)

let write_arith_result_no_CF_OF (locked, sz, w, e) =
  write_arith_eflags_except_CF_OF (sz,w) >>
  wEA (locked,e,w)

let write_logical_result (locked, sz, w, e) =
  write_arith_eflags_except_CF_OF (sz,w) >>
  wEA (locked,e,w)

let push i =
  ea_imm_rm i >>= fun w__0 ->
  EA (B0,w__0) >>= fun w__1 ->
  push_aux w__1

let read_dest_src_ea (locked, sz, ds) =
  ea_dest (sz,ds) >>= fun e ->
  EA (locked,e) >>= fun w__0 ->
  ea_src (sz,ds) >>= fun w__1 ->
  EA (locked,w__1) >>= fun w__2 ->
  return (e,w__0,w__2)

let write_logical_eflags (sz, w) = write_arith_eflags (sz,w,B0,B0)

let write_arith_result (locked, sz, w, c, x, e) =
  write_arith_eflags (sz,w,c,x) >>
  wEA (locked,e,w)

let write_monop (locked, sz, mop, a, e) =
  match mop with
  | X86_Not -> wEA (locked,e,reset_vector_start (bitwise_not a))
  | X86_Dec -> write_arith_result_no_CF_OF (locked,sz,reset_vector_start (minus_VIV a (1:ii)),e)
  | X86_Inc -> write_arith_result_no_CF_OF (locked,sz,reset_vector_start (add_VIV a (1:ii)),e)
  | X86_Neg ->
     write_arith_result_no_CF_OF (locked,sz,reset_vector_start (minus_IVV (0:ii) a),e) >>
     write_reg CF (to_vec_dec_undef (1:ii))
  end

let write_binop (locked, sz, bop, a, b, e) =
  match bop with
  | X86_Add ->
     let (w, c, x) =
       match (add_with_carry_out (sz,a,b)) with | (v0v', v1v', v2v') -> (v0v',v1v',v2v') end in
     write_arith_result (locked,sz,w,c,x,e)
  | X86_Sub ->
     let (w, c, x) =
       match (sub_with_borrow (sz,a,b)) with | (v3v', v4v', v5v') -> (v3v',v4v',v5v') end in
     write_arith_result (locked,sz,w,c,x,e)
  | X86_Cmp ->
     let (w, c, x) =
       match (sub_with_borrow (sz,a,b)) with | (v6v', v7v', v8v') -> (v6v',v7v',v8v') end in
     write_arith_eflags (sz,w,c,x)
  | X86_Test -> write_logical_eflags (sz,reset_vector_start (bitwise_and (a, b)))
  | X86_And -> write_logical_result (locked,sz,reset_vector_start (bitwise_and (a, b)),e)
  | X86_Xor -> write_logical_result (locked,sz,reset_vector_start (bitwise_xor (a, b)),e)
  | X86_Or -> write_logical_result (locked,sz,reset_vector_start (bitwise_or (a, b)),e)
  | X86_Rol -> write_result_erase_eflags (locked,rol (sz,a,b),e)
  | X86_Ror -> write_result_erase_eflags (locked,ror (sz,a,b),e)
  | X86_Sar -> write_result_erase_eflags (locked,sar (sz,a,b),e)
  | X86_Shl ->
     write_result_erase_eflags
       (locked,
        reset_vector_start (bitwise_leftshift (a, mask_shift (sz,b))),
        e)
  | X86_Shr ->
     write_result_erase_eflags
       (locked,
        reset_vector_start (bitwise_rightshift (a, mask_shift (sz,b))),
        e)
  | X86_Adc ->
     read_reg CF >>= fun w__0 ->
     let carry = most_significant w__0 in
     let result = add_VVV a (reset_vector_start (add_VBV b carry)) in
     write_reg CF (Vector [lteq (value_width sz, (unsigned a) + (unsigned b))] 0 false) >>
     write_reg OF (to_vec_dec_undef (1:ii)) >>
     write_arith_result_no_CF_OF (locked,sz,result,e)
  | X86_Sbb ->
     read_reg CF >>= fun w__1 ->
     let carry = most_significant w__1 in
     let result = minus_VVV a (reset_vector_start (add_VBV b carry)) in
     write_reg
       CF
       (Vector [lt (unsigned a, (unsigned b) + (match carry with | B0 -> (0:ii) | B1 -> (1:ii) end))] 0 false) >>
     write_reg OF (to_vec_dec_undef (1:ii)) >>
     write_arith_result_no_CF_OF (locked,sz,result,e)
  | _ -> exit ()
  end



let execute_Binop (locked, bop, sz, ds) =
  read_dest_src_ea (locked,sz,ds) >>= fun w__0 ->
  let (e, val_dst, val_src) = match w__0 with | (v0v', v1v', v2v') -> (v0v',v1v',v2v') end in
  write_binop (locked,sz,bop,val_dst,val_src,e)

let execute_Bitop (locked, bop, sz, boffset) =
  bit_offset_ea (sz,boffset) >>= fun w__0 ->
  let (base_ea, offset) = match w__0 with | (v3v', v4v') -> (v3v',v4v') end in
  EA (locked,base_ea) >>= fun word ->
  let bitval = access word offset in
  let word = update_pos word offset (match bop with | Bts -> B1 | Btc -> ~bitval | Btr -> B0 end) in
  write_reg CF (Vector [bitval] 0 false) >>
  wEA (locked,base_ea,word)

let execute_CALL i =
  push_rip () >>
  ea_imm_rm i >>= fun w__0 ->
  jump_to_ea w__0

let execute_CLC () = write_reg CF (Vector [B0] 0 false)

let execute_CMC () =
  read_reg CF >>= fun w__0 ->
  write_reg CF (bitwise_not (reset_vector_start w__0))

let execute_CMPXCHG (locked, sz, r, n) =
  let src = Ea_r (sz,n) in
  let acc = Ea_r (sz,(0:ii)) in
  ea_rm (sz,r) >>= fun dst ->
  EA (locked,dst) >>= fun val_dst ->
  EA (B0,acc) >>= fun val_acc ->
  write_binop (locked,sz,X86_Cmp,val_acc,val_dst,src) >>
  if bitU_to_bool (eq_vec (val_acc, val_dst))
  then
    EA (B0,src) >>= fun w__0 ->
    wEA (locked,dst,w__0)
  else
    wEA (B0,acc,val_dst) >>
    wEA (locked,dst,val_dst)

let execute_X86_DIV (sz, r) =
  let w = value_width sz in
  let eax = Ea_r (sz,(0:ii)) in
  let edx = Ea_r (sz,(2:ii)) in
  EA (B0,edx) >>= fun w__0 ->
  EA (B0,eax) >>= fun w__1 ->
  let n = ((unsigned w__0) * w) + (unsigned w__1) in
  ea_rm (sz,r) >>= fun w__2 ->
  EA (B0,w__2) >>= fun w__3 ->
  let d = unsigned w__3 in
  let q = quot n d in
  let m = modulo n d in
  if bitU_to_bool ((eq_range (d, (0:ii))) |. (lt (w, q)))
  then exit ()
  else
    wEA (B0,eax,to_vec_dec ((64:ii),q)) >>
    wEA (B0,edx,to_vec_dec ((64:ii),m)) >>
    erase_eflags ()

let execute_HLT () = return ()

let execute_Jcc (c, i) =
  read_cond c >>= fun w__0 ->
  if bitU_to_bool w__0
  then
    read_reg RIP >>= fun w__1 ->
    write_reg RIP (add_VVV w__1 i)
  else return ()

let execute_JMP r =
  ea_rm (Sz64,r) >>= fun w__0 ->
  EA (B0,w__0) >>= fun w__1 ->
  write_reg RIP w__1

let execute_LEA (sz, ds) =
  ea_src (sz,ds) >>= fun src ->
  ea_dest (sz,ds) >>= fun dst ->
  wEA (B0,dst,get_ea_address src)

let execute_LEAVE () =
  read_reg RBP >>= fun w__0 ->
  write_reg RSP w__0 >>
  pop (X86_Reg (5:ii))

let execute_LOOP (c, i) =
  read_reg RCX >>= fun w__0 ->
  write_reg RCX (minus_VIV w__0 (1:ii)) >>
  read_reg RCX >>= fun w__1 ->
  read_cond c >>= fun w__2 ->
  if bitU_to_bool ((neq_vec_range (w__1, (0:ii))) &. w__2)
  then
    read_reg RIP >>= fun w__3 ->
    write_reg RIP (add_VVV w__3 i)
  else return ()

let execute_MFENCE () = X86_MFENCE ()

let execute_Monop (locked, mop, sz, r) =
  ea_rm (sz,r) >>= fun e ->
  EA (locked,e) >>= fun w__0 ->
  write_monop (locked,sz,mop,w__0,e)

let execute_MOV (c, sz, ds) =
  read_cond c >>= fun w__0 ->
  if bitU_to_bool w__0
  then
    ea_src (sz,ds) >>= fun src ->
    ea_dest (sz,ds) >>= fun dst ->
    EA (B0,src) >>= fun w__1 ->
    wEA (B0,dst,w__1)
  else return ()

let execute_MOVSX (sz1, ds, sz2) =
  ea_src (sz1,ds) >>= fun src ->
  ea_dest (sz2,ds) >>= fun dst ->
  EA (B0,src) >>= fun w__0 ->
  wEA (B0,dst,sign_extension (w__0,sz1,sz2))

let execute_MOVZX (sz1, ds, sz2) =
  ea_src (sz1,ds) >>= fun src ->
  ea_dest (sz2,ds) >>= fun dst ->
  EA (B0,src) >>= fun w__0 ->
  wEA (B0,dst,w__0)

let execute_X86_MUL (sz, r) =
  let eax = Ea_r (sz,(0:ii)) in
  EA (B0,eax) >>= fun val_eax ->
  ea_rm (sz,r) >>= fun w__0 ->
  EA (B0,w__0) >>= fun val_src ->
  match sz with
  | Sz8 (_) ->
     wEA
       (B0,
        Ea_r (Sz16,(0:ii)),
        reset_vector_start (slice (set_vector_start_to_length (mult_VVV val_eax val_src))
                              (63:ii) (0:ii)))
  | _ ->
     let m = mult_VVV val_eax val_src in
     let edx = Ea_r (sz,(2:ii)) in
     wEA (B0,eax,reset_vector_start (slice (set_vector_start_to_length m) (63:ii) (0:ii))) >>
     wEA
       (B0,
        edx,
        reset_vector_start (slice (set_vector_start_to_length
                              (bitwise_rightshift (set_vector_start_to_length m, size_width sz)))
                              (63:ii) (0:ii)))
  end

let execute_X86_NOP _ = return ()

let execute_POP r = pop r

let execute_PUSH i = push i

let execute_RET i =
  pop_rip () >>
  drop i

let execute_SET (c, b, r) =
  ea_rm (Sz8 b,r) >>= fun w__0 ->
  read_cond c >>= fun w__1 ->
  wEA
    (B0,
     w__0,
     if bitU_to_bool w__1
     then to_vec_dec ((64:ii),(1:ii))
     else to_vec_dec ((64:ii),(0:ii)))

let execute_STC () = write_reg CF (Vector [B1] 0 false)

let execute_XADD (locked, sz, r, n) =
  let src = Ea_r (sz,n) in
  ea_rm (sz,r) >>= fun dst ->
  EA (B0,src) >>= fun val_src ->
  EA (locked,dst) >>= fun val_dst ->
  wEA (B0,src,val_dst) >>
  write_binop (locked,sz,X86_Add,val_src,val_dst,dst)

let execute_XCHG (locked, sz, r, n) =
  let src = Ea_r (sz,n) in
  ea_rm (sz,r) >>= fun dst ->
  EA (B0,src) >>= fun val_src ->
  EA (locked,dst) >>= fun val_dst ->
  wEA (B0,src,val_dst) >>
  wEA (locked,dst,val_src)

let execute = function
  
  | Binop (locked,bop,sz,ds) -> execute_Binop (locked,bop,sz,ds)
  | Bitop (locked,bop,sz,boffset) -> execute_Bitop (locked,bop,sz,boffset)
  | CALL (i) -> execute_CALL (i)
  | CLC -> execute_CLC ()
  | CMC -> execute_CMC ()
  | CMPXCHG (locked,sz,r,n) -> execute_CMPXCHG (locked,sz,r,n)
  | X86_DIV (sz,r) -> execute_X86_DIV (sz,r)
  | HLT -> execute_HLT ()
  | Jcc (c,i) -> execute_Jcc (c,i)
  | JMP (r) -> execute_JMP (r)
  | LEA (sz,ds) -> execute_LEA (sz,ds)
  | LEAVE -> execute_LEAVE ()
  | LOOP (c,i) -> execute_LOOP (c,i)
  | MFENCE -> execute_MFENCE ()
  | Monop (locked,mop,sz,r) -> execute_Monop (locked,mop,sz,r)
  | MOV (c,sz,ds) -> execute_MOV (c,sz,ds)
  | MOVSX (sz1,ds,sz2) -> execute_MOVSX (sz1,ds,sz2)
  | MOVZX (sz1,ds,sz2) -> execute_MOVZX (sz1,ds,sz2)
  | X86_MUL (sz,r) -> execute_X86_MUL (sz,r)
  | X86_NOP ((_ as arg0)) -> execute_X86_NOP (arg0)
  | POP (r) -> execute_POP (r)
  | PUSH (i) -> execute_PUSH (i)
  | RET (i) -> execute_RET (i)
  | SET (c,b,r) -> execute_SET (c,b,r)
  | STC -> execute_STC ()
  | XADD (locked,sz,r,n) -> execute_XADD (locked,sz,r,n)
  | XCHG (locked,sz,r,n) -> execute_XCHG (locked,sz,r,n)
  end

